{
    "docs": [
        {
            "location": "/", 
            "text": "Quiet Modem Project\n\n\nQuiet Modem Project is an easy way to provide low-throughput communication for websites and apps without requiring access to Internet or pairing between two devices. It is a set of cross-platform libraries that allow you to encode data as sound and transmit it with a speaker. A device or application with the Quiet Modem can then detect this sound and receive the encoded data. This sound can be audible or nearly ultrasonic. \nForward Error Correction\n applied to the message helps preserve the data against errors in transmission, while \nChecksums\n discard messages received incorrectly.\n\n\nLive Demo\n\n\n\n\nAll of the Quiet Modem's libraries, and its dependencies, are licensed under a mix of BSD and MIT, allowing a versatile range of use cases. Quiet's source is freely available and can be audited, which ensures that your user's microphone data is safe. Quiet Modem is offered in \nC\n, \nJavascript\n, \nAndroid\n and \niOS\n. It provides bindings to soundcards on each platform so that you can simply encode data on one side and decode on the other.\n\n\nThe Quiet Modem is configured with a JSON-based profile system that allows you to change a wide range of behaviors at runtime. Quiet is built on top of a \nhighly capable DSP/SDR library\n which provides it with good robustness, even at distances up to 1 meter.", 
            "title": "Quiet Modem"
        }, 
        {
            "location": "/#quiet-modem-project", 
            "text": "Quiet Modem Project is an easy way to provide low-throughput communication for websites and apps without requiring access to Internet or pairing between two devices. It is a set of cross-platform libraries that allow you to encode data as sound and transmit it with a speaker. A device or application with the Quiet Modem can then detect this sound and receive the encoded data. This sound can be audible or nearly ultrasonic.  Forward Error Correction  applied to the message helps preserve the data against errors in transmission, while  Checksums  discard messages received incorrectly.", 
            "title": "Quiet Modem Project"
        }, 
        {
            "location": "/#live-demo", 
            "text": "All of the Quiet Modem's libraries, and its dependencies, are licensed under a mix of BSD and MIT, allowing a versatile range of use cases. Quiet's source is freely available and can be audited, which ensures that your user's microphone data is safe. Quiet Modem is offered in  C ,  Javascript ,  Android  and  iOS . It provides bindings to soundcards on each platform so that you can simply encode data on one side and decode on the other.  The Quiet Modem is configured with a JSON-based profile system that allows you to change a wide range of behaviors at runtime. Quiet is built on top of a  highly capable DSP/SDR library  which provides it with good robustness, even at distances up to 1 meter.", 
            "title": "Live Demo"
        }, 
        {
            "location": "/setup/", 
            "text": "Getting Started\n\n\nInstalling tools\n\n\nlibquiet requires \nCmake\n for its builds.\n\n\nInstalling Dependencies\n\n\n\n\n\n\nInstall \nlibcorrect\n\n\n\n\n\n\nInstall \nliquid dsp\n. The \ndevel\n branch \nmust\n be installed.\n\n\n\n\n\n\nInstall \nlibjansson\n\n\n\n\n\n\n(Optional) Install \nPortAudio\n which allows Quiet to interface with your soundcard. This is highly recommended.\n\n\n\n\n\n\n(Optional) Install \nlibsndfile\n which allows Quiet to read and write .wav files containing encoded sounds.\n\n\n\n\n\n\nInstalling libquiet\n\n\nAfter installing all dependencies, clone \nlibquiet\n, cd to directory where it is cloned, then run\n\n\nmkdir build\n\ncd build\n\ncmake ..\n\nmake\n\nmake install\n\n\n\n\n\nHeaders\n\n\nTo access libquiet's API,\n\n\n#include\n \nquiet.h\n\n\n\n\n\n\nIf you have installed PortAudio and have installed libquiet's PortAudio wrapper, you can access the PortAudio-backed transmitter and receiver with\n\n\n#include\n \nquiet-portaudio.h\n\n\n\n\n\n\nLinking\n\n\nMake sure that \nlibquiet.so\n or \nlibquiet.dylib\n is in your \nLDPATH\n.\n\n\nFor static linking, you'll want to link against \nlibquiet\n, \nlibjansson\n, \nlibliquid\n and \nlibfec\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/setup/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/setup/#installing-tools", 
            "text": "libquiet requires  Cmake  for its builds.", 
            "title": "Installing tools"
        }, 
        {
            "location": "/setup/#installing-dependencies", 
            "text": "Install  libcorrect    Install  liquid dsp . The  devel  branch  must  be installed.    Install  libjansson    (Optional) Install  PortAudio  which allows Quiet to interface with your soundcard. This is highly recommended.    (Optional) Install  libsndfile  which allows Quiet to read and write .wav files containing encoded sounds.", 
            "title": "Installing Dependencies"
        }, 
        {
            "location": "/setup/#installing-libquiet", 
            "text": "After installing all dependencies, clone  libquiet , cd to directory where it is cloned, then run  mkdir build\n\ncd build\n\ncmake ..\n\nmake\n\nmake install", 
            "title": "Installing libquiet"
        }, 
        {
            "location": "/setup/#headers", 
            "text": "To access libquiet's API,  #include   quiet.h   If you have installed PortAudio and have installed libquiet's PortAudio wrapper, you can access the PortAudio-backed transmitter and receiver with  #include   quiet-portaudio.h", 
            "title": "Headers"
        }, 
        {
            "location": "/setup/#linking", 
            "text": "Make sure that  libquiet.so  or  libquiet.dylib  is in your  LDPATH .  For static linking, you'll want to link against  libquiet ,  libjansson ,  libliquid  and  libfec .", 
            "title": "Linking"
        }, 
        {
            "location": "/example/", 
            "text": "This is a brief example to demonstrate how Quiet works. Full examples can be found for interfacing with your soundcard and with .WAV files in the \nrepo on Github\n.\n\n\nTransmitting\n\n\nWe'll start by writing the message \"Hello, World!\" into soundwaves. We'll choose an audible frequency so that it will be easy to confirm that something is being transmitted.\n\n\n#include\n \nstring.h\n\n\n\n#include\n \nunistd.h\n\n\n\n\n\n#include\n \nquiet-portaudio.h\n\n\n\n\n\nint\n \nmain\n()\n\n\n\n{\n\n\n    \n/* start up PortAudio, which will interface quiet to the soundcard */\n\n\n    \nPa_Initialize\n();\n\n\n\n\n    \n/* get a profile and set up encoder options, which controls Quiet\ns modem */\n\n\n    \nquiet_encoder_options\n \n*\nencodeOpt\n \n=\n\n\n        \nquiet_encoder_profile_filename\n(\n/usr/local/share/quiet/quiet-profiles.json\n,\n \naudible\n);\n\n\n\n\n    \n/* get some default options about device and soundcard setup from PortAudio */\n\n\n    \nPaDeviceIndex\n \ndevice\n \n=\n \nPa_GetDefaultOutputDevice\n();\n\n\n    \nconst\n \nPaDeviceInfo\n \n*\ndeviceInfo\n \n=\n \nPa_GetDeviceInfo\n(\ndevice\n);\n\n\n    \ndouble\n \nsampleRate\n \n=\n \ndeviceInfo\n-\ndefaultSampleRate\n;\n\n\n    \nPaTime\n \nlatency\n \n=\n \ndeviceInfo\n-\ndefaultLowOutputLatency\n;\n\n\n\n\n    \n/* select a power of 2 sample buffer size to interface soundcard with\n\n\n\n     * this should be between 128 and 16384 */\n\n\n    \nconst\n \nsize_t\n \nsampleBufferSize\n \n=\n \n(\n1\n \n \n14\n);\n\n\n\n\n    \n/* start the quiet/PortAudio interface */\n\n\n    \nquiet_portaudio_encoder\n \n*\nencoder\n \n=\n\n\n        \nquiet_portaudio_encoder_create\n(\nencodeOpt\n,\n \ndevice\n,\n \nlatency\n,\n \nsampleRate\n,\n \nsampleBufferSize\n);\n\n\n\n\n    \n/* create our message in a uint8_t array */\n\n\n    \nconst\n \nuint8_t\n \nmsg\n[]\n \n=\n \nHello, World!\n;\n\n\n\n\n    \n/* send the message. this just writes to a send queue\n\n\n\n     * behind the scenes, quiet will encode and send as sound samples */\n\n\n    \nquiet_portaudio_encoder_send\n(\nencoder\n,\n \nmsg\n,\n \nsizeof\n(\nmsg\n));\n\n\n\n\n    \n/* stop the quiet/PortAudio interface */\n\n\n    \nquiet_portaudio_encoder_close\n(\nencoder\n);\n\n\n    \nquiet_portaudio_encoder_destroy\n(\nencoder\n);\n\n\n\n\n    \n/* free encoder options we created earlier */\n\n\n    \nfree\n(\nencodeOpt\n);\n\n\n\n\n    \n/* shut down PortAudio */\n\n\n    \nPa_Terminate\n();\n\n\n\n\n    \nreturn\n \n0\n;\n\n\n\n}\n\n\n\n\n\n\nNow compile and run the resulting program. If this example is saved as \nencoder.c\n then\n\n\nclang encoder.c -o encoder -lquiet -ljansson -lportaudio -lliquid -lfec\n\n\n\n\n\nThe resulting program will be compiled as \nencoder\n. Running with \n./encoder\n should emit a short audible tone and then quit.\n\n\nReceiving\n\n\n#include\n \nstring.h\n\n\n\n#include\n \nunistd.h\n\n\n\n\n\n#include\n \nquiet-portaudio.h\n\n\n\n\n\nint\n \nmain\n()\n\n\n\n{\n\n\n    \n/* start up PortAudio, which will interface quiet to the soundcard */\n\n\n    \nPa_Initialize\n();\n\n\n\n\n    \n/* get a profile and set up decoder options, which controls Quiet\ns modem */\n\n\n    \nquiet_decoder_options\n \n*\ndecodeOpt\n \n=\n\n\n        \nquiet_decoder_profile_filename\n(\n/usr/local/share/quiet/quiet-profiles.json\n,\n \naudible\n);\n\n\n\n\n    \n/* get some default options about device and soundcard setup from PortAudio */\n\n\n    \nPaDeviceIndex\n \ndevice\n \n=\n \nPa_GetDefaultInputDevice\n();\n\n\n    \nconst\n \nPaDeviceInfo\n \n*\ndeviceInfo\n \n=\n \nPa_GetDeviceInfo\n(\ndevice\n);\n\n\n    \ndouble\n \nsampleRate\n \n=\n \ndeviceInfo\n-\ndefaultSampleRate\n;\n\n\n    \nPaTime\n \nlatency\n \n=\n \ndeviceInfo\n-\ndefaultLowInputLatency\n;\n\n\n\n\n    \n/* select a power of 2 sample buffer size to interface soundcard with\n\n\n\n     * this should be between 128 and 16384 */\n\n\n    \nconst\n \nsize_t\n \nsampleBufferSize\n \n=\n \n(\n1\n \n \n14\n);\n\n\n\n\n    \n/* start the quiet/PortAudio interface */\n\n\n    \nquiet_portaudio_decoder\n \n*\ndecoder\n \n=\n\n\n        \nquiet_portaudio_decoder_create\n(\ndecodeOpt\n,\n \ndevice\n,\n \nlatency\n,\n \nsampleRate\n,\n \nsampleBufferSize\n);\n\n\n\n\n    \n/* recover message of up to 1024 bytes */\n\n\n    \nconst\n \nsize_t\n \nwriteBufferSize\n \n=\n \n1024\n;\n\n\n    \nuint8_t\n \n*\nwriteBuffer\n \n=\n \nmalloc\n(\nwriteBufferSize\n);\n\n\n\n\n    \nwhile\n \n(\ntrue\n)\n \n{\n\n\n        \n/* pump some samples from soundcard into quiet */\n\n\n        \nquiet_portaudio_decoder_consume\n(\ndecoder\n);\n\n\n\n\n        \n/* check quiet\ns receive buffer */\n\n\n        \nssize_t\n \nread\n \n=\n \nquiet_portaudio_decoder_recv\n(\ndecoder\n,\n \nwriteBuffer\n,\n \nwriteBufferSize\n);\n\n\n        \nif\n \n(\nread\n \n \n0\n)\n \n{\n\n\n            \ncontinue\n;\n\n\n        \n}\n\n\n\n\n        \n/* read succeeded, so we have a message. print it out. */\n\n\n        \nprintf\n(\n%.*s\n\\n\n,\n \nread\n,\n \nwriteBuffer\n);\n\n\n\n\n        \n/* we are done */\n\n\n        \nbreak\n;\n\n\n    \n}\n\n\n\n\n    \n/* free message buffer and quiet/PortAudio interface */\n\n\n    \nfree\n(\nwriteBuffer\n);\n\n\n    \nquiet_portaudio_decoder_destroy\n(\ndecoder\n);\n\n\n\n\n    \n/* free decoder options we created earlier */\n\n\n    \nfree\n(\ndecodeOpt\n);\n\n\n\n\n    \n/* shut down PortAudio */\n\n\n    \nPa_Terminate\n();\n\n\n\n\n    \nreturn\n \n0\n;\n\n\n\n}\n\n\n\n\n\n\nNow compile and run. If this example is saved as \ndecoder.c\n then\n\n\nclang decoder.c -o decoder -lquiet -ljansson -lportaudio -lliquid -lfec\n\n\n\n\n\nshould do the trick.\n\n\nEnd-to-end\n\n\nNow that both are compiled, start the decoder in the background first\n\n\n./decoder \n\n\n\n\n\n\nand then the encoder\n\n\n./encoder\n\n\n\n\n\nYou should hear an audible tone and see the message \"Hello, World!\" printed on your console. Both programs will then exit.", 
            "title": "Example"
        }, 
        {
            "location": "/example/#transmitting", 
            "text": "We'll start by writing the message \"Hello, World!\" into soundwaves. We'll choose an audible frequency so that it will be easy to confirm that something is being transmitted.  #include   string.h  #include   unistd.h  #include   quiet-portaudio.h  int   main ()  { \n\n     /* start up PortAudio, which will interface quiet to the soundcard */ \n\n     Pa_Initialize (); \n\n\n\n     /* get a profile and set up encoder options, which controls Quiet s modem */ \n\n     quiet_encoder_options   * encodeOpt   = \n\n         quiet_encoder_profile_filename ( /usr/local/share/quiet/quiet-profiles.json ,   audible ); \n\n\n\n     /* get some default options about device and soundcard setup from PortAudio */ \n\n     PaDeviceIndex   device   =   Pa_GetDefaultOutputDevice (); \n\n     const   PaDeviceInfo   * deviceInfo   =   Pa_GetDeviceInfo ( device ); \n\n     double   sampleRate   =   deviceInfo - defaultSampleRate ; \n\n     PaTime   latency   =   deviceInfo - defaultLowOutputLatency ; \n\n\n\n     /* select a power of 2 sample buffer size to interface soundcard with       * this should be between 128 and 16384 */ \n\n     const   size_t   sampleBufferSize   =   ( 1     14 ); \n\n\n\n     /* start the quiet/PortAudio interface */ \n\n     quiet_portaudio_encoder   * encoder   = \n\n         quiet_portaudio_encoder_create ( encodeOpt ,   device ,   latency ,   sampleRate ,   sampleBufferSize ); \n\n\n\n     /* create our message in a uint8_t array */ \n\n     const   uint8_t   msg []   =   Hello, World! ; \n\n\n\n     /* send the message. this just writes to a send queue       * behind the scenes, quiet will encode and send as sound samples */ \n\n     quiet_portaudio_encoder_send ( encoder ,   msg ,   sizeof ( msg )); \n\n\n\n     /* stop the quiet/PortAudio interface */ \n\n     quiet_portaudio_encoder_close ( encoder ); \n\n     quiet_portaudio_encoder_destroy ( encoder ); \n\n\n\n     /* free encoder options we created earlier */ \n\n     free ( encodeOpt ); \n\n\n\n     /* shut down PortAudio */ \n\n     Pa_Terminate (); \n\n\n\n     return   0 ;  }   Now compile and run the resulting program. If this example is saved as  encoder.c  then  clang encoder.c -o encoder -lquiet -ljansson -lportaudio -lliquid -lfec  The resulting program will be compiled as  encoder . Running with  ./encoder  should emit a short audible tone and then quit.", 
            "title": "Transmitting"
        }, 
        {
            "location": "/example/#receiving", 
            "text": "#include   string.h  #include   unistd.h  #include   quiet-portaudio.h  int   main ()  { \n\n     /* start up PortAudio, which will interface quiet to the soundcard */ \n\n     Pa_Initialize (); \n\n\n\n     /* get a profile and set up decoder options, which controls Quiet s modem */ \n\n     quiet_decoder_options   * decodeOpt   = \n\n         quiet_decoder_profile_filename ( /usr/local/share/quiet/quiet-profiles.json ,   audible ); \n\n\n\n     /* get some default options about device and soundcard setup from PortAudio */ \n\n     PaDeviceIndex   device   =   Pa_GetDefaultInputDevice (); \n\n     const   PaDeviceInfo   * deviceInfo   =   Pa_GetDeviceInfo ( device ); \n\n     double   sampleRate   =   deviceInfo - defaultSampleRate ; \n\n     PaTime   latency   =   deviceInfo - defaultLowInputLatency ; \n\n\n\n     /* select a power of 2 sample buffer size to interface soundcard with       * this should be between 128 and 16384 */ \n\n     const   size_t   sampleBufferSize   =   ( 1     14 ); \n\n\n\n     /* start the quiet/PortAudio interface */ \n\n     quiet_portaudio_decoder   * decoder   = \n\n         quiet_portaudio_decoder_create ( decodeOpt ,   device ,   latency ,   sampleRate ,   sampleBufferSize ); \n\n\n\n     /* recover message of up to 1024 bytes */ \n\n     const   size_t   writeBufferSize   =   1024 ; \n\n     uint8_t   * writeBuffer   =   malloc ( writeBufferSize ); \n\n\n\n     while   ( true )   { \n\n         /* pump some samples from soundcard into quiet */ \n\n         quiet_portaudio_decoder_consume ( decoder ); \n\n\n\n         /* check quiet s receive buffer */ \n\n         ssize_t   read   =   quiet_portaudio_decoder_recv ( decoder ,   writeBuffer ,   writeBufferSize ); \n\n         if   ( read     0 )   { \n\n             continue ; \n\n         } \n\n\n\n         /* read succeeded, so we have a message. print it out. */ \n\n         printf ( %.*s \\n ,   read ,   writeBuffer ); \n\n\n\n         /* we are done */ \n\n         break ; \n\n     } \n\n\n\n     /* free message buffer and quiet/PortAudio interface */ \n\n     free ( writeBuffer ); \n\n     quiet_portaudio_decoder_destroy ( decoder ); \n\n\n\n     /* free decoder options we created earlier */ \n\n     free ( decodeOpt ); \n\n\n\n     /* shut down PortAudio */ \n\n     Pa_Terminate (); \n\n\n\n     return   0 ;  }   Now compile and run. If this example is saved as  decoder.c  then  clang decoder.c -o decoder -lquiet -ljansson -lportaudio -lliquid -lfec  should do the trick.", 
            "title": "Receiving"
        }, 
        {
            "location": "/example/#end-to-end", 
            "text": "Now that both are compiled, start the decoder in the background first  ./decoder    and then the encoder  ./encoder  You should hear an audible tone and see the message \"Hello, World!\" printed on your console. Both programs will then exit.", 
            "title": "End-to-end"
        }, 
        {
            "location": "/how/", 
            "text": "How It Works\n\n\nQuiet Modem encodes your data into sound that can be played by your speakers. These sounds can then be detected through a microphone and converted back into data.\n\n\nThis section of the documentation is optional\n. It can be skipped if you just wish to begin using the modem. However, if you need to debug your modem, it can be helpful to understand how these libraries work.\n\n\nSoundcard\n\n\n\n\nIn order to understand what it means to play sound, it helps to first demonstrate how your sounds work within your computer. When we want to represent a sound, we sample it at periodic intervals in time. Each sample is rounded to one of thousands of discrete intensity levels in a process known as \nPulse-Code Modulation\n. We refer to the number of samples represented in a single second as the sample rate. The most common sample rate for digital audio is 44,100 Hz (samples per second). The sample rate applies both to sounds that we want to play and sounds that we are recording. The computer has a sound card or chip which is responsible for converting analog sounds to digital samples and vice versa.\n\n\n\n\nlibquiet can build bindings to \nPortAudio\n which can handle the soundcard interfacing on most platforms automatically.\n\n\n\n\nModulation\n\n\n\n\n\n\nAs described in the section on soundcards, we will be operating on individual samples of sound. We know that we will be sending and receiving individual samples, each of which can be assigned a single floating-point value. We also know that these values will eventually have to be played as analog electrical signals which excite sounds through a speaker. We will convert data to sample values through a process known as modulation.\n\n\nQuiet Modem uses \nLiquid SDR\n to do the heavily lifting for its modulation tasks. This section is describing mostly how parts of Liquid work. The key points are repeated in this documentation so that users of Quiet should not have to rely too heavily on Liquid's documentation.\n\n\nFraming\n\n\nQuiet Modem sends data in chunks, which we will call frames. Each frame can be thought of as a completely self-contained packet of data. The start of each frame contains a synchronization sequence that allows the receiver to have a good chance of decoding the frame. Quiet performs checksumming on the contents of each frame so that it can discard frames that have picked up errors in transmission.\n\n\nA single frame of data has a maxium payload size that it can carry. This size will depend on the specific configuration used, but in general, a frame will be converted into at most one or two seconds of sound. Frames that are longer than this are more likely to encounter errors.\n\n\n\n\nIt is up to the user of Quiet's libraries to split data into frames.\n Quiet will discard frames that are longer than the configured transmitter's maximum frame length. Although this is somewhat inconvenient, the upside is that frames are given back to the user in the same structure when received. This means that if you wish to use e.g. the first byte of each frame to signal when a message is starting or ending, you will always be able to find this marker at the first byte.\n\n\n\n\nChecksum\n\n\nQuiet offers automatic \nchecksum verification\n of frames. The strongest of these methods offered is \nCRC32\n which will fail nearly every time if even a single bit in the received frame is incorrect. Some applications may wish to disable checksums if receiving an incorrect message is preferable to receiving no message.\n\n\nFor this step, Quiet generates the checksum and then sets it aside for later. The checksum itself will be passed in a different part of the frame from where the user payload goes.\n\n\nError Correction\n\n\nBefore we modulate our frame, we can add redundancy to it. This redundancy allows the receiver to recover our original message even when some errors occur in transmission. This process is known as \nForward Error Correction\n.\n\n\nAs an example, you can imagine that we repeat each bit of our message three times. Then when the receiver receives this message, it picks whichever bit occurs most often \n if two of these three bits are '0' and one is '1', then we pick '0' as the original message bit.\n\n\nModern forward error correction is more sophisticated than simply repeating bits, but, as a consequence, not as easy to explain. Quiet Modem relies on the modes provided by Liquid SDR. In particular, it makes use of \nConvolutional Codes\n and \nReed-Solomon\n. Once we apply these methods to our original message, we take the resulting bits and pass them on to our modulator.\n\n\nPayload Modulator\n\n\nLiquid SDR offers a wide range of modulation options, and so it is beyond the scope of this page to fully explain all of them. If you are curious which specific options Quiet provides, the documentation on \nProfiles\n offers more details. Quiet makes use of Liquid's standard modems, OFDM and GMSK modes. For this section, we will explore one of the most basic modes, BPSK.\n\n\nIn \nbinary phase-shift keying\n, we assign each bit of the message we want to send into a sequence of floating-point samples. Each sample will represent a single bit of data. If we want to send a binary '0', then we create a new sample with a floating-point value of -1.0. If we instead want to send binary '1', then we assign the value of 1.0. Other modulation schemes can send more bits of data in each sample by picking more intermediate values, e.g. -0.5 and 0.5 and even \ncomplex values\n.\n\n\nWe now have floating-point samples where previously we had binary digits. If you were given the sequence created above, it would be easy to recover the original message. Unfortunately, we would not have much luck simply sending this sequence as it is. We will need to condition these samples so that they can deal with limitations in our real-world speaker. We will also need to make it easier for the receiver to find where our message starts.\n\n\nTransmitting\n\n\n\n\n\n\nJust as in our section on modulation, this section mostly describes functionality provided by Liquid DSP.\n\n\nPreamble\n\n\nOur receiver will be looking at a continuous stream of floating-point samples from the soundcard, waiting to see our message. These samples will contain all of the background noise near the microphone as well as whatever message we are sending. We need a way to tell the receiver that our message is about to begin so that it will know to interpret the samples it is seeing as message bits.\n\n\nThe way that we accomplish this is by using a predetermined, pseudorandom sequence of samples. We will start every message we send with this sequence so that the receiver will know unambiguously that our message is about to start. It will be much easier for the receiver to look for this specific sequence and then assume that the message follows immediately after. This sequence is known as the preamble. The preamble does \nnot\n need to be modulated \n the sequence itself is what we send.\n\n\nHeader\n\n\nThe header is a short block of data sent before the payload. The header contains information on which type of modulation and error correction are used in the payload. It also contains the actual checksum generated for the payload. A short checksum is sent for the contents of the header itself.\n\n\nHeader Modulator\n\n\nJust as our message was modulated to floating-point samples, we will apply error correction and modulation to the data in the header. The kinds used here can be different from the one used for the payload. We want the header to be especially reliable since an error in the header can make it impossible to receive the payload correctly.\n\n\nWe do not send the type of modulation or error correction used for the header itself. These values are pre-shared and are part of the modem configuration.\n\n\nAssembling the Frame\n\n\nWe now have all of the samples needed to send our frame. We start by sending the preamble samples, followed by the header samples, and finally the payload samples.\n\n\nInterpolation\n\n\nInterpolation is a process that allows us to restrict how quickly our signal changes values by inserting new 'fill' samples between each of our existing samples. We will fill in samples with values of 0 so that they do not change the overall energy in the signal. Next, all samples (original + fill) have their values smoothed out by evaluating a specially chosen polynomial that prefers slow changes in values over fast changes in values. In other words, we use a filter.\n\n\nThe new sequence of resulting samples will change less rapidly than the original, restricted to a narrower band of frequencies. The number of fill samples we choose allows us to control how much smaller the band gets. Inserting a single sample halves the range; inserting two reduces it to a third, and so on. Using a narrower frequency band will often give our data a better chance of being transmitted successfully. The downside is that it now takes us more samples to send the same message, which means our effective transmission speed is reduced.\n\n\nWe will apply this interpolation to the full contents of the frame, not just the part with our message.\n\n\nUpconversion\n\n\nOur interpolator reduced the bandwidth of our message, but the resulting waveform is very low frequency, centered at 0 Hz. Speakers do not work well at very low frequencies, so we will want to move our message out of that range through upconversion. Upconversion allows us to move the center of this transmission up to a new frequency, but with the same bandwidth as before upconversion.\n\n\nFor example, if our original transmission has a bandwidth of 4,000 Hz, and we upconvert it by 8,000 Hz, then it will sit at the range of 6,000 Hz to 10,000 Hz after upconversion.\n\n\nThis process is what allows us to go into the near-ultrasonic range. If we use interpolation to reduce our transmission be fairly narrow and then upconvert to 19kHz or so, the result will sit entirely above 18kHz, which is well above the hearing range for nearly everyone.\n\n\nGain Reduction\n\n\nThis step multiplies all values in the signal by some small fraction. This reduces the likelihood that the signal will clip beyond the acceptable range of [-1.0, 1.0], which our soundcard would reject. It also makes the transmission quieter so that it will be a reasonable volume regardless of how loud the user's volume settings are set to.\n\n\nBlock Buffer\n\n\nWe now have a stream of floating-point samples that is ready to be sent through the speaker. Soundcards expect to receive samples in blocks instead of one sample at a time. The soundcard's block length has to be preconfigured and some power of 2, commonly in the range of 256 (2^8) to 16384 (2^16). This step collects samples into bunches to match the soundcard's block length.\n\n\nIf too many samples are generated to fit into one block, Quiet sends one block's worth and stores the rest for the next block. If more samples are needed to fill a block, Quiet checks its send queue to see if more data frames are ready and fills with silence otherwise.\n\n\nReceiving\n\n\n\n\n\n\nThe receiver is running on a separate device from the transmitter. Here we will take samples collected by our microphone and decode the transmitted message.\n\n\nBlock Buffer\n\n\nThe soundcard will have collected floating-point samples of sound recorded by the microphone. These samples are sent to us in blocks made of multiple samples, just as when we sent samples to the speaker. Each block's length is a some power of 2.\n\n\nOur block buffer serves as a temporary store of samples as we run the decoding process.\n\n\nDownconversion\n\n\nWe have to invert the upconversion process so that the original signal's center is shifted back down to 0 Hz. This should be matched to the transmitter so that we shift down by the same frequency interval that we shifted up.\n\n\nDecimation\n\n\nThis step inverts interpolation. First we apply a low-pass filter to our signal and then we throw away samples. This should also be matched to the transmitter. For example, if we had chosen to interpolate by 2, now we will decimate by 2.\n\n\nFrame Detection\n\n\nThe resulting stream of samples should now resemble what we transmitted. When we sent our frame, we started it with a preamble. Now we will search for the preamble in the incoming samples. This is an ongoing process and will continue to run as long as no preamble is found.\n\n\nSynchronization and Equalization\n\n\nThe preamble is made up of a few different parts. The first part of the preamble is easily detectable so that we know where the frame begins. The next part of the preamble helps us synchronize our timing to the transmitter's timing in a precise way.\n\n\nFrom the section on Payload Modulation, we described how we convert binary data into floating-point amplitudes. One of the challenges we face in decoding is deciding at which point it will be appropriate to read these floating-point samples. The preamble helps us accomplish this by giving us a predictable sequence to look for. Even if noise is present on top of the preamble, we can still achieve a pretty good synchronization by looking for successive samples.\n\n\nWe will also use the preamble to compensate for the uneven frequency response of the transmit and receive channel. It is typical that our transmission channel will emphasize certain frequencies and attenuate others. We use the preamble to invert this bias introduced by the channel so that the signal we receive looks nearly flat again.\n\n\nDemodulate Header\n\n\nWith our clock aligned to the transmitter's, we are ready to begin decoding data. We start by decoding the modulated header samples. This data includes checksums of the payload and the header itself, as well as the type of modulation and error correection used in the payload. If the checksum of the decoded header data matches the checksum sent with the header, then we proceed to decoding the payload.\n\n\nDemodulation\n\n\n\n\n\n\nDemodulation\n\n\nUsing the demodulation method specified by the header, we now demodulate all of the frame's payload samples. We perform \nsoft demodulation\n so that the samples are demodulated into 8-bit \"soft\" bits. That is, for each bit of data transmitted, we now have an 8-bit value that reflects our belief about what might have been transmitted. A soft bit of 0 means that we are highly confident that a 0 was transmitted, 255 means that we are highly confident that a 1 was transmitted, and intermediate values mean we have some level of uncertainty. A value of 128 means that we believe either bit was equally likely. Preserving this level of uncertainty will help us during the error correction phase, as bits with lower confidence will accumulate less error.\n\n\nTo use our BPSK example from the modulation section, where we transmitted -1.0 for '0' and 1.0 for '1', imagine that we receive the sequence [0.9, -0.95, 0.1, 0.9]. If we were to decode these back to single bits, then we would decode this sequence as [1, 0, 1, 1]. However, if we use soft bits, we get [242, 6, 140, 242]. This better captures our uncertainty about the '0.1' sample we received, which is nearly as likely to be '0' as it is '1'.\n\n\nError Correction\n\n\nNow that we have the soft bits demodulated, our next step will be to apply the error correction techniques for the redundancy we added during modulation. The error correction will need to be good enough to decode the samples in spite of other noise occuring. Even the signal itself becomes noise, as echoes of the signal are picked up by the microphone.\n\n\nData Integrity\n\n\nFinally, we take the checksum value stored in the header and compare to a checksum of the data recovered after error correction. If these checksums match, we can be relatively confident that we have received the transmitted message. The bits can now be passed to the user.\n\n\nThe checksum stage is optional. Some applications may be well suited to receive messages with some errors. It is up to the user of Quiet Modem to decide whether to checksums should be used.\n\n\nThread Safety\n\n\n\n\nThe Quiet Modem library has some features that help it work well in a \nmultithreaded\n environment. In particular, Quiet assumes that the interface to the soundcard will run on a different thread than the user application. Quiet attempts to decouple its functionality so that it can be used in a threadsafe way.\n\n\nRing Buffer\n\n\nOne of the key components of Quiet's threadsafety is a \nring buffer\n that allows safe communication between threads. Quiet's ring buffer allows any number of readers and any number of writers. If the buffer is empty or full, it has mechanisms to allow readers and writers to block until data or space in the buffer is available.\n\n\nIn general, we try to keep frames of data in buffers, rather than modulated samples. This is because a modulated frame uses much more memory than the demodulated payload data.\n\n\nSend Queue\n\n\nOn the transmit side of Quiet, we use a ringbuffer to build a send queue. This allows senders to queue up packets for transmission as capacity allows. When the soundcard is ready for more samples, Quiet can read from the send queue and modulate one or more frames to fill up the soundcard buffer as necessary.\n\n\nReceive Queue\n\n\nOn the receive side of Quiet, we have a receive queue. Samples are continuously read from the microphone into Quiet's decoder. When it has successfully decoded a packet, the packet's payload is written as a complete frame into the receive queue. Users of Quiet can perform a blocking read of this queue which will wait until a frame is ready.", 
            "title": "How It Works"
        }, 
        {
            "location": "/how/#how-it-works", 
            "text": "Quiet Modem encodes your data into sound that can be played by your speakers. These sounds can then be detected through a microphone and converted back into data.  This section of the documentation is optional . It can be skipped if you just wish to begin using the modem. However, if you need to debug your modem, it can be helpful to understand how these libraries work.", 
            "title": "How It Works"
        }, 
        {
            "location": "/how/#soundcard", 
            "text": "In order to understand what it means to play sound, it helps to first demonstrate how your sounds work within your computer. When we want to represent a sound, we sample it at periodic intervals in time. Each sample is rounded to one of thousands of discrete intensity levels in a process known as  Pulse-Code Modulation . We refer to the number of samples represented in a single second as the sample rate. The most common sample rate for digital audio is 44,100 Hz (samples per second). The sample rate applies both to sounds that we want to play and sounds that we are recording. The computer has a sound card or chip which is responsible for converting analog sounds to digital samples and vice versa.   libquiet can build bindings to  PortAudio  which can handle the soundcard interfacing on most platforms automatically.", 
            "title": "Soundcard"
        }, 
        {
            "location": "/how/#modulation", 
            "text": "As described in the section on soundcards, we will be operating on individual samples of sound. We know that we will be sending and receiving individual samples, each of which can be assigned a single floating-point value. We also know that these values will eventually have to be played as analog electrical signals which excite sounds through a speaker. We will convert data to sample values through a process known as modulation.  Quiet Modem uses  Liquid SDR  to do the heavily lifting for its modulation tasks. This section is describing mostly how parts of Liquid work. The key points are repeated in this documentation so that users of Quiet should not have to rely too heavily on Liquid's documentation.", 
            "title": "Modulation"
        }, 
        {
            "location": "/how/#framing", 
            "text": "Quiet Modem sends data in chunks, which we will call frames. Each frame can be thought of as a completely self-contained packet of data. The start of each frame contains a synchronization sequence that allows the receiver to have a good chance of decoding the frame. Quiet performs checksumming on the contents of each frame so that it can discard frames that have picked up errors in transmission.  A single frame of data has a maxium payload size that it can carry. This size will depend on the specific configuration used, but in general, a frame will be converted into at most one or two seconds of sound. Frames that are longer than this are more likely to encounter errors.   It is up to the user of Quiet's libraries to split data into frames.  Quiet will discard frames that are longer than the configured transmitter's maximum frame length. Although this is somewhat inconvenient, the upside is that frames are given back to the user in the same structure when received. This means that if you wish to use e.g. the first byte of each frame to signal when a message is starting or ending, you will always be able to find this marker at the first byte.", 
            "title": "Framing"
        }, 
        {
            "location": "/how/#checksum", 
            "text": "Quiet offers automatic  checksum verification  of frames. The strongest of these methods offered is  CRC32  which will fail nearly every time if even a single bit in the received frame is incorrect. Some applications may wish to disable checksums if receiving an incorrect message is preferable to receiving no message.  For this step, Quiet generates the checksum and then sets it aside for later. The checksum itself will be passed in a different part of the frame from where the user payload goes.", 
            "title": "Checksum"
        }, 
        {
            "location": "/how/#error-correction", 
            "text": "Before we modulate our frame, we can add redundancy to it. This redundancy allows the receiver to recover our original message even when some errors occur in transmission. This process is known as  Forward Error Correction .  As an example, you can imagine that we repeat each bit of our message three times. Then when the receiver receives this message, it picks whichever bit occurs most often   if two of these three bits are '0' and one is '1', then we pick '0' as the original message bit.  Modern forward error correction is more sophisticated than simply repeating bits, but, as a consequence, not as easy to explain. Quiet Modem relies on the modes provided by Liquid SDR. In particular, it makes use of  Convolutional Codes  and  Reed-Solomon . Once we apply these methods to our original message, we take the resulting bits and pass them on to our modulator.", 
            "title": "Error Correction"
        }, 
        {
            "location": "/how/#payload-modulator", 
            "text": "Liquid SDR offers a wide range of modulation options, and so it is beyond the scope of this page to fully explain all of them. If you are curious which specific options Quiet provides, the documentation on  Profiles  offers more details. Quiet makes use of Liquid's standard modems, OFDM and GMSK modes. For this section, we will explore one of the most basic modes, BPSK.  In  binary phase-shift keying , we assign each bit of the message we want to send into a sequence of floating-point samples. Each sample will represent a single bit of data. If we want to send a binary '0', then we create a new sample with a floating-point value of -1.0. If we instead want to send binary '1', then we assign the value of 1.0. Other modulation schemes can send more bits of data in each sample by picking more intermediate values, e.g. -0.5 and 0.5 and even  complex values .  We now have floating-point samples where previously we had binary digits. If you were given the sequence created above, it would be easy to recover the original message. Unfortunately, we would not have much luck simply sending this sequence as it is. We will need to condition these samples so that they can deal with limitations in our real-world speaker. We will also need to make it easier for the receiver to find where our message starts.", 
            "title": "Payload Modulator"
        }, 
        {
            "location": "/how/#transmitting", 
            "text": "Just as in our section on modulation, this section mostly describes functionality provided by Liquid DSP.", 
            "title": "Transmitting"
        }, 
        {
            "location": "/how/#preamble", 
            "text": "Our receiver will be looking at a continuous stream of floating-point samples from the soundcard, waiting to see our message. These samples will contain all of the background noise near the microphone as well as whatever message we are sending. We need a way to tell the receiver that our message is about to begin so that it will know to interpret the samples it is seeing as message bits.  The way that we accomplish this is by using a predetermined, pseudorandom sequence of samples. We will start every message we send with this sequence so that the receiver will know unambiguously that our message is about to start. It will be much easier for the receiver to look for this specific sequence and then assume that the message follows immediately after. This sequence is known as the preamble. The preamble does  not  need to be modulated   the sequence itself is what we send.", 
            "title": "Preamble"
        }, 
        {
            "location": "/how/#header", 
            "text": "The header is a short block of data sent before the payload. The header contains information on which type of modulation and error correction are used in the payload. It also contains the actual checksum generated for the payload. A short checksum is sent for the contents of the header itself.", 
            "title": "Header"
        }, 
        {
            "location": "/how/#header-modulator", 
            "text": "Just as our message was modulated to floating-point samples, we will apply error correction and modulation to the data in the header. The kinds used here can be different from the one used for the payload. We want the header to be especially reliable since an error in the header can make it impossible to receive the payload correctly.  We do not send the type of modulation or error correction used for the header itself. These values are pre-shared and are part of the modem configuration.", 
            "title": "Header Modulator"
        }, 
        {
            "location": "/how/#assembling-the-frame", 
            "text": "We now have all of the samples needed to send our frame. We start by sending the preamble samples, followed by the header samples, and finally the payload samples.", 
            "title": "Assembling the Frame"
        }, 
        {
            "location": "/how/#interpolation", 
            "text": "Interpolation is a process that allows us to restrict how quickly our signal changes values by inserting new 'fill' samples between each of our existing samples. We will fill in samples with values of 0 so that they do not change the overall energy in the signal. Next, all samples (original + fill) have their values smoothed out by evaluating a specially chosen polynomial that prefers slow changes in values over fast changes in values. In other words, we use a filter.  The new sequence of resulting samples will change less rapidly than the original, restricted to a narrower band of frequencies. The number of fill samples we choose allows us to control how much smaller the band gets. Inserting a single sample halves the range; inserting two reduces it to a third, and so on. Using a narrower frequency band will often give our data a better chance of being transmitted successfully. The downside is that it now takes us more samples to send the same message, which means our effective transmission speed is reduced.  We will apply this interpolation to the full contents of the frame, not just the part with our message.", 
            "title": "Interpolation"
        }, 
        {
            "location": "/how/#upconversion", 
            "text": "Our interpolator reduced the bandwidth of our message, but the resulting waveform is very low frequency, centered at 0 Hz. Speakers do not work well at very low frequencies, so we will want to move our message out of that range through upconversion. Upconversion allows us to move the center of this transmission up to a new frequency, but with the same bandwidth as before upconversion.  For example, if our original transmission has a bandwidth of 4,000 Hz, and we upconvert it by 8,000 Hz, then it will sit at the range of 6,000 Hz to 10,000 Hz after upconversion.  This process is what allows us to go into the near-ultrasonic range. If we use interpolation to reduce our transmission be fairly narrow and then upconvert to 19kHz or so, the result will sit entirely above 18kHz, which is well above the hearing range for nearly everyone.", 
            "title": "Upconversion"
        }, 
        {
            "location": "/how/#gain-reduction", 
            "text": "This step multiplies all values in the signal by some small fraction. This reduces the likelihood that the signal will clip beyond the acceptable range of [-1.0, 1.0], which our soundcard would reject. It also makes the transmission quieter so that it will be a reasonable volume regardless of how loud the user's volume settings are set to.", 
            "title": "Gain Reduction"
        }, 
        {
            "location": "/how/#block-buffer", 
            "text": "We now have a stream of floating-point samples that is ready to be sent through the speaker. Soundcards expect to receive samples in blocks instead of one sample at a time. The soundcard's block length has to be preconfigured and some power of 2, commonly in the range of 256 (2^8) to 16384 (2^16). This step collects samples into bunches to match the soundcard's block length.  If too many samples are generated to fit into one block, Quiet sends one block's worth and stores the rest for the next block. If more samples are needed to fill a block, Quiet checks its send queue to see if more data frames are ready and fills with silence otherwise.", 
            "title": "Block Buffer"
        }, 
        {
            "location": "/how/#receiving", 
            "text": "The receiver is running on a separate device from the transmitter. Here we will take samples collected by our microphone and decode the transmitted message.", 
            "title": "Receiving"
        }, 
        {
            "location": "/how/#block-buffer_1", 
            "text": "The soundcard will have collected floating-point samples of sound recorded by the microphone. These samples are sent to us in blocks made of multiple samples, just as when we sent samples to the speaker. Each block's length is a some power of 2.  Our block buffer serves as a temporary store of samples as we run the decoding process.", 
            "title": "Block Buffer"
        }, 
        {
            "location": "/how/#downconversion", 
            "text": "We have to invert the upconversion process so that the original signal's center is shifted back down to 0 Hz. This should be matched to the transmitter so that we shift down by the same frequency interval that we shifted up.", 
            "title": "Downconversion"
        }, 
        {
            "location": "/how/#decimation", 
            "text": "This step inverts interpolation. First we apply a low-pass filter to our signal and then we throw away samples. This should also be matched to the transmitter. For example, if we had chosen to interpolate by 2, now we will decimate by 2.", 
            "title": "Decimation"
        }, 
        {
            "location": "/how/#frame-detection", 
            "text": "The resulting stream of samples should now resemble what we transmitted. When we sent our frame, we started it with a preamble. Now we will search for the preamble in the incoming samples. This is an ongoing process and will continue to run as long as no preamble is found.", 
            "title": "Frame Detection"
        }, 
        {
            "location": "/how/#synchronization-and-equalization", 
            "text": "The preamble is made up of a few different parts. The first part of the preamble is easily detectable so that we know where the frame begins. The next part of the preamble helps us synchronize our timing to the transmitter's timing in a precise way.  From the section on Payload Modulation, we described how we convert binary data into floating-point amplitudes. One of the challenges we face in decoding is deciding at which point it will be appropriate to read these floating-point samples. The preamble helps us accomplish this by giving us a predictable sequence to look for. Even if noise is present on top of the preamble, we can still achieve a pretty good synchronization by looking for successive samples.  We will also use the preamble to compensate for the uneven frequency response of the transmit and receive channel. It is typical that our transmission channel will emphasize certain frequencies and attenuate others. We use the preamble to invert this bias introduced by the channel so that the signal we receive looks nearly flat again.", 
            "title": "Synchronization and Equalization"
        }, 
        {
            "location": "/how/#demodulate-header", 
            "text": "With our clock aligned to the transmitter's, we are ready to begin decoding data. We start by decoding the modulated header samples. This data includes checksums of the payload and the header itself, as well as the type of modulation and error correection used in the payload. If the checksum of the decoded header data matches the checksum sent with the header, then we proceed to decoding the payload.", 
            "title": "Demodulate Header"
        }, 
        {
            "location": "/how/#demodulation", 
            "text": "", 
            "title": "Demodulation"
        }, 
        {
            "location": "/how/#demodulation_1", 
            "text": "Using the demodulation method specified by the header, we now demodulate all of the frame's payload samples. We perform  soft demodulation  so that the samples are demodulated into 8-bit \"soft\" bits. That is, for each bit of data transmitted, we now have an 8-bit value that reflects our belief about what might have been transmitted. A soft bit of 0 means that we are highly confident that a 0 was transmitted, 255 means that we are highly confident that a 1 was transmitted, and intermediate values mean we have some level of uncertainty. A value of 128 means that we believe either bit was equally likely. Preserving this level of uncertainty will help us during the error correction phase, as bits with lower confidence will accumulate less error.  To use our BPSK example from the modulation section, where we transmitted -1.0 for '0' and 1.0 for '1', imagine that we receive the sequence [0.9, -0.95, 0.1, 0.9]. If we were to decode these back to single bits, then we would decode this sequence as [1, 0, 1, 1]. However, if we use soft bits, we get [242, 6, 140, 242]. This better captures our uncertainty about the '0.1' sample we received, which is nearly as likely to be '0' as it is '1'.", 
            "title": "Demodulation"
        }, 
        {
            "location": "/how/#error-correction_1", 
            "text": "Now that we have the soft bits demodulated, our next step will be to apply the error correction techniques for the redundancy we added during modulation. The error correction will need to be good enough to decode the samples in spite of other noise occuring. Even the signal itself becomes noise, as echoes of the signal are picked up by the microphone.", 
            "title": "Error Correction"
        }, 
        {
            "location": "/how/#data-integrity", 
            "text": "Finally, we take the checksum value stored in the header and compare to a checksum of the data recovered after error correction. If these checksums match, we can be relatively confident that we have received the transmitted message. The bits can now be passed to the user.  The checksum stage is optional. Some applications may be well suited to receive messages with some errors. It is up to the user of Quiet Modem to decide whether to checksums should be used.", 
            "title": "Data Integrity"
        }, 
        {
            "location": "/how/#thread-safety", 
            "text": "The Quiet Modem library has some features that help it work well in a  multithreaded  environment. In particular, Quiet assumes that the interface to the soundcard will run on a different thread than the user application. Quiet attempts to decouple its functionality so that it can be used in a threadsafe way.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/how/#ring-buffer", 
            "text": "One of the key components of Quiet's threadsafety is a  ring buffer  that allows safe communication between threads. Quiet's ring buffer allows any number of readers and any number of writers. If the buffer is empty or full, it has mechanisms to allow readers and writers to block until data or space in the buffer is available.  In general, we try to keep frames of data in buffers, rather than modulated samples. This is because a modulated frame uses much more memory than the demodulated payload data.", 
            "title": "Ring Buffer"
        }, 
        {
            "location": "/how/#send-queue", 
            "text": "On the transmit side of Quiet, we use a ringbuffer to build a send queue. This allows senders to queue up packets for transmission as capacity allows. When the soundcard is ready for more samples, Quiet can read from the send queue and modulate one or more frames to fill up the soundcard buffer as necessary.", 
            "title": "Send Queue"
        }, 
        {
            "location": "/how/#receive-queue", 
            "text": "On the receive side of Quiet, we have a receive queue. Samples are continuously read from the microphone into Quiet's decoder. When it has successfully decoded a packet, the packet's payload is written as a complete frame into the receive queue. Users of Quiet can perform a blocking read of this queue which will wait until a frame is ready.", 
            "title": "Receive Queue"
        }, 
        {
            "location": "/transmitting/", 
            "text": "Transmitting Data\n\n\nquiet_portaudio_encoder\n\n\nstruct\n \nquiet_portaudio_encoder\n;\n\n\n\ntypedef\n \nstruct\n \nquiet_portaudio_encoder\n \nquiet_portaudio_encoder\n;\n\n\n\n\n\n\nquiet_portaudio_encoder_create\n\n\nquiet_portaudio_encoder\n \n*\n\n\n\nquiet_portaudio_encoder_create\n(\nconst\n \nquiet_encoder_options\n \n*\nopt\n,\n\n\n                               \nPaDeviceIndex\n \ndevice\n,\n\n\n                               \nPaTime\n \nlatency\n,\n\n\n                               \ndouble\n \nsample_rate\n,\n\n\n                               \nsize_t\n \nsample_buffer_size\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_set_blocking\n\n\nvoid\n\n\n\nquiet_portaudio_encoder_set_blocking\n(\nquiet_portaudio_encoder\n \n*\ne\n,\n\n\n                                     \ntime_t\n \nsec\n,\n\n\n                                     \nlong\n \nnano\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_set_nonblocking\n\n\nvoid\n\n\n\nquiet_portaudio_encoder_set_nonblocking\n(\nquiet_portaudio_encoder\n \n*\ne\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_get_frame_len\n\n\nsize_t\n\n\n\nquiet_portaudio_encoder_get_frame_len\n(\nconst\n \nquiet_portaudio_encoder\n \n*\ne\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_clamp_frame_len\n\n\nsize_t\n\n\n\nquiet_portaudio_encoder_clamp_frame_len\n(\nquiet_portaudio_encoder\n \n*\ne\n,\n\n\n                                        \nsize_t\n \nsample_len\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_send\n\n\nssize_t\n\n\n\nquiet_portaudio_encoder_send\n(\nquiet_portaudio_encoder\n \n*\nenc\n,\n\n\n                             \nconst\n \nuint8_t\n \n*\nbuf\n,\n\n\n                             \nsize_t\n \nlen\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_emit\n\n\nssize_t\n\n\n\nquiet_portaudio_encoder_emit\n(\nquiet_portaudio_encoder\n \n*\nenc\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_emit_empty\n\n\nvoid\n\n\n\nquiet_portaudio_encoder_emit_empty\n(\nquiet_portaudio_encoder\n \n*\nenc\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_close\n\n\nvoid\n\n\n\nquiet_portaudio_encoder_close\n(\nquiet_portaudio_encoder\n \n*\nenc\n);\n\n\n\n\n\n\nquiet_portaudio_encoder_destroy\n\n\nvoid\n\n\n\nquiet_portaudio_encoder_destroy\n(\nquiet_portaudio_encoder\n \n*\nenc\n);", 
            "title": "Transmitting Data"
        }, 
        {
            "location": "/transmitting/#transmitting-data", 
            "text": "", 
            "title": "Transmitting Data"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder", 
            "text": "struct   quiet_portaudio_encoder ;  typedef   struct   quiet_portaudio_encoder   quiet_portaudio_encoder ;", 
            "title": "quiet_portaudio_encoder"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_create", 
            "text": "quiet_portaudio_encoder   *  quiet_portaudio_encoder_create ( const   quiet_encoder_options   * opt , \n\n                                PaDeviceIndex   device , \n\n                                PaTime   latency , \n\n                                double   sample_rate , \n\n                                size_t   sample_buffer_size );", 
            "title": "quiet_portaudio_encoder_create"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_set_blocking", 
            "text": "void  quiet_portaudio_encoder_set_blocking ( quiet_portaudio_encoder   * e , \n\n                                      time_t   sec , \n\n                                      long   nano );", 
            "title": "quiet_portaudio_encoder_set_blocking"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_set_nonblocking", 
            "text": "void  quiet_portaudio_encoder_set_nonblocking ( quiet_portaudio_encoder   * e );", 
            "title": "quiet_portaudio_encoder_set_nonblocking"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_get_frame_len", 
            "text": "size_t  quiet_portaudio_encoder_get_frame_len ( const   quiet_portaudio_encoder   * e );", 
            "title": "quiet_portaudio_encoder_get_frame_len"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_clamp_frame_len", 
            "text": "size_t  quiet_portaudio_encoder_clamp_frame_len ( quiet_portaudio_encoder   * e , \n\n                                         size_t   sample_len );", 
            "title": "quiet_portaudio_encoder_clamp_frame_len"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_send", 
            "text": "ssize_t  quiet_portaudio_encoder_send ( quiet_portaudio_encoder   * enc , \n\n                              const   uint8_t   * buf , \n\n                              size_t   len );", 
            "title": "quiet_portaudio_encoder_send"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_emit", 
            "text": "ssize_t  quiet_portaudio_encoder_emit ( quiet_portaudio_encoder   * enc );", 
            "title": "quiet_portaudio_encoder_emit"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_emit_empty", 
            "text": "void  quiet_portaudio_encoder_emit_empty ( quiet_portaudio_encoder   * enc );", 
            "title": "quiet_portaudio_encoder_emit_empty"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_close", 
            "text": "void  quiet_portaudio_encoder_close ( quiet_portaudio_encoder   * enc );", 
            "title": "quiet_portaudio_encoder_close"
        }, 
        {
            "location": "/transmitting/#quiet_portaudio_encoder_destroy", 
            "text": "void  quiet_portaudio_encoder_destroy ( quiet_portaudio_encoder   * enc );", 
            "title": "quiet_portaudio_encoder_destroy"
        }, 
        {
            "location": "/receiving/", 
            "text": "Receiving Data\n\n\nquiet_portaudio_decoder\n\n\nstruct\n \nquiet_portaudio_decoder\n;\n\n\n\ntypedef\n \nstruct\n \nquiet_portaudio_decoder\n \nquiet_portaudio_decoder\n;\n\n\n\n\n\n\nquiet_portaudio_decoder_create\n\n\nquiet_portaudio_decoder\n \n*\n\n\n\nquiet_portaudio_decoder_create\n(\nconst\n \nquiet_decoder_options\n \n*\nopt\n,\n\n\n                               \nPaDeviceIndex\n \ndevice\n,\n\n\n                               \nPaTime\n \nlatency\n,\n\n\n                               \ndouble\n \nsample_rate\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_recv\n\n\nssize_t\n\n\n\nquiet_portaudio_decoder_recv\n(\nquiet_portaudio_decoder\n \n*\nd\n,\n\n\n                             \nuint8_t\n \n*\ndata\n,\n\n\n                             \nsize_t\n \nlen\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_set_blocking\n\n\nvoid\n\n\n\nquiet_portaudio_decoder_set_blocking\n(\nquiet_portaudio_decoder\n \n*\nd\n,\n\n\n                                     \ntime_t\n \nsec\n,\n\n\n                                     \nlong\n \nnano\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_set_nonblocking\n\n\nvoid\n\n\n\nquiet_portaudio_decoder_set_nonblocking\n(\nquiet_portaudio_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_frame_in_progress\n\n\nbool\n\n\n\nquiet_portaudio_decoder_frame_in_progress\n(\nquiet_portaudio_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_checksum_fails\n\n\nunsigned\n \nint\n\n\n\nquiet_portaudio_decoder_checksum_fails\n(\nconst\n \nquiet_portaudio_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_consume_stats\n\n\nconst\n \nquiet_decoder_frame_stats\n \n*\n\n\n\nquiet_portaudio_decoder_consume_stats\n(\nquiet_portaudio_decoder\n \n*\nd\n,\n\n\n                                      \nsize_t\n \n*\nnum_frames\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_enable_stats\n\n\nvoid\n\n\n\nquiet_portaudio_decoder_enable_stats\n(\nquiet_portaudio_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_disable_stats\n\n\nvoid\n\n\n\nquiet_portaudio_decoder_disable_stats\n(\nquiet_portaudio_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_close\n\n\nvoid\n\n\n\nquiet_portaudio_decoder_close\n(\nquiet_portaudio_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_portaudio_decoder_destroy\n\n\nvoid\n\n\n\nquiet_portaudio_decoder_destroy\n(\nquiet_portaudio_decoder\n \n*\nd\n);", 
            "title": "Receiving Data"
        }, 
        {
            "location": "/receiving/#receiving-data", 
            "text": "", 
            "title": "Receiving Data"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder", 
            "text": "struct   quiet_portaudio_decoder ;  typedef   struct   quiet_portaudio_decoder   quiet_portaudio_decoder ;", 
            "title": "quiet_portaudio_decoder"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_create", 
            "text": "quiet_portaudio_decoder   *  quiet_portaudio_decoder_create ( const   quiet_decoder_options   * opt , \n\n                                PaDeviceIndex   device , \n\n                                PaTime   latency , \n\n                                double   sample_rate );", 
            "title": "quiet_portaudio_decoder_create"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_recv", 
            "text": "ssize_t  quiet_portaudio_decoder_recv ( quiet_portaudio_decoder   * d , \n\n                              uint8_t   * data , \n\n                              size_t   len );", 
            "title": "quiet_portaudio_decoder_recv"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_set_blocking", 
            "text": "void  quiet_portaudio_decoder_set_blocking ( quiet_portaudio_decoder   * d , \n\n                                      time_t   sec , \n\n                                      long   nano );", 
            "title": "quiet_portaudio_decoder_set_blocking"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_set_nonblocking", 
            "text": "void  quiet_portaudio_decoder_set_nonblocking ( quiet_portaudio_decoder   * d );", 
            "title": "quiet_portaudio_decoder_set_nonblocking"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_frame_in_progress", 
            "text": "bool  quiet_portaudio_decoder_frame_in_progress ( quiet_portaudio_decoder   * d );", 
            "title": "quiet_portaudio_decoder_frame_in_progress"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_checksum_fails", 
            "text": "unsigned   int  quiet_portaudio_decoder_checksum_fails ( const   quiet_portaudio_decoder   * d );", 
            "title": "quiet_portaudio_decoder_checksum_fails"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_consume_stats", 
            "text": "const   quiet_decoder_frame_stats   *  quiet_portaudio_decoder_consume_stats ( quiet_portaudio_decoder   * d , \n\n                                       size_t   * num_frames );", 
            "title": "quiet_portaudio_decoder_consume_stats"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_enable_stats", 
            "text": "void  quiet_portaudio_decoder_enable_stats ( quiet_portaudio_decoder   * d );", 
            "title": "quiet_portaudio_decoder_enable_stats"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_disable_stats", 
            "text": "void  quiet_portaudio_decoder_disable_stats ( quiet_portaudio_decoder   * d );", 
            "title": "quiet_portaudio_decoder_disable_stats"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_close", 
            "text": "void  quiet_portaudio_decoder_close ( quiet_portaudio_decoder   * d );", 
            "title": "quiet_portaudio_decoder_close"
        }, 
        {
            "location": "/receiving/#quiet_portaudio_decoder_destroy", 
            "text": "void  quiet_portaudio_decoder_destroy ( quiet_portaudio_decoder   * d );", 
            "title": "quiet_portaudio_decoder_destroy"
        }, 
        {
            "location": "/configuration/", 
            "text": "Modem Configuration\n\n\nThe primary configuration structures for libquiet are \nquiet_encoder_options\n and \nquiet_decoder_options\n. Although it is possible to modify values in these structures, it is generally recommended to use the JSON-based configuration system instead, as that system works consistently across all platforms. This page documents how to configure from the JSON profiles as well as the raw configuration structures themselves.\n\n\nquiet_decoder_profile_file\n\n\nquiet_decoder_options\n \n*\n\n\n\nquiet_decoder_profile_file\n(\nFILE\n \n*\nf\n,\n\n\n                           \nconst\n \nchar\n \n*\nprofilename\n);\n\n\n\n\n\n\nlibquiet's configuration options are fairly numerous, and testing can be frustrating when configuration requires recompilation. For this reason, libquiet provides a JSON file containing multiple sets of configuration  profiles  and functions to read and validate them.\n\n\nEach profile provides access to every option contained in quiet_encoder_options/quiet_decoder_options. It is hoped that this will give good default options and provide a starting place for users to tune new profiles.\n\n\nquiet_decoder_profile_file reads the profile given by profilename from the file pointer and returns the corresponding \nquiet_decoder_options\n.\n\n\nParameters\n\n\nf\n - file pointer which contains a valid JSON libquiet profile set\n\n\nprofilename\n - the string key of the profile to fetch\n\n\nReturns\n\n\na pointer to an initialized \nquiet_decoder_options\n or NULL if decoding failed. must be freed by caller (with free()).\n\n\nquiet_decoder_profile_filename\n\n\nquiet_decoder_options\n \n*\n\n\n\nquiet_decoder_profile_filename\n(\nconst\n \nchar\n \n*\nfname\n,\n\n\n                               \nconst\n \nchar\n \n*\nprofilename\n);\n\n\n\n\n\n\nquiet_decoder_profile_filename reads the profile given by profilename from the file located at filename and returns the corresponding \nquiet_decoder_options\n.\n\n\nParameters\n\n\nfname\n - path to a file which will be opened and read, must contain a valid JSON liquiet profile set\n\n\nprofilename\n - the string key of the profile to fetch\n\n\nReturns\n\n\na pointer to an initialized \nquiet_decoder_options\n or NULL if decoding failed. must be freed by caller (with free()).\n\n\nquiet_decoder_profile_str\n\n\nquiet_decoder_options\n \n*\n\n\n\nquiet_decoder_profile_str\n(\nconst\n \nchar\n \n*\ninput\n,\n\n\n                          \nconst\n \nchar\n \n*\nprofilename\n);\n\n\n\n\n\n\nquiet_decoder_profile_str reads the profile given by profilename from the input and returns the corresponding \nquiet_decoder_options\n.\n\n\nParameters\n\n\ninput\n - a string containing a valid JSON libquiet profile set\n\n\nprofilename\n - the string key of the profile to fetch\n\n\nReturns\n\n\na pointer to an initialized \nquiet_decoder_options\n or NULL if decoding failed. must be freed by caller (with free()).\n\n\nquiet_encoder_profile_file\n\n\nquiet_encoder_options\n \n*\n\n\n\nquiet_encoder_profile_file\n(\nFILE\n \n*\nf\n,\n\n\n                           \nconst\n \nchar\n \n*\nprofilename\n);\n\n\n\n\n\n\nquiet_encoder_profile_file reads the profile given by profilename from the file pointer and returns the corresponding \nquiet_encoder_options\n.\n\n\nParameters\n\n\nf\n - file pointer which contains a valid JSON libquiet profile set\n\n\nprofilename\n - the string key of the profile to fetch\n\n\nReturns\n\n\na pointer to an initialized \nquiet_encoder_options\n or NULL if decoding failed. must be freed by caller (with free()).\n\n\nquiet_encoder_profile_filename\n\n\nquiet_encoder_options\n \n*\n\n\n\nquiet_encoder_profile_filename\n(\nconst\n \nchar\n \n*\nfname\n,\n\n\n                               \nconst\n \nchar\n \n*\nprofilename\n);\n\n\n\n\n\n\nquiet_encoder_profile_filename reads the profile given by profilename from the file located at filename and returns the corresponding \nquiet_encoder_options\n.\n\n\nParameters\n\n\nfname\n - path to a file which will be opened and read, must contain a valid JSON liquiet profile set\n\n\nprofilename\n - the string key of the profile to fetch\n\n\nReturns\n\n\na pointer to an initialized \nquiet_encoder_options\n or NULL if decoding failed. must be freed by caller (with free()).\n\n\nquiet_encoder_profile_str\n\n\nquiet_encoder_options\n \n*\n\n\n\nquiet_encoder_profile_str\n(\nconst\n \nchar\n \n*\ninput\n,\n\n\n                          \nconst\n \nchar\n \n*\nprofilename\n);\n\n\n\n\n\n\nquiet_encoder_profile_str reads the profile given by profilename from the input and returns the corresponding \nquiet_encoder_options\n.\n\n\nParameters\n\n\ninput\n - a string containing a valid JSON libquiet profile set\n\n\nprofilename\n - the string key of the profile to fetch\n\n\nReturns\n\n\na pointer to an initialized \nquiet_encoder_options\n or NULL if decoding failed. must be freed by caller (with free()).\n\n\nquiet_encoder_options\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nquiet_ofdm_options\n \nofdmopt\n;\n\n\n    \nquiet_modulator_options\n \nmodopt\n;\n\n\n    \nquiet_resampler_options\n \nresampler\n;\n\n\n    \nquiet_encoding_t\n \nencoding\n;\n\n\n    \nquiet_checksum_scheme_t\n \nchecksum_scheme\n;\n\n\n    \nquiet_error_correction_scheme_t\n \ninner_fec_scheme\n;\n\n\n    \nquiet_error_correction_scheme_t\n \nouter_fec_scheme\n;\n\n\n    \nquiet_modulation_scheme_t\n \nmod_scheme\n;\n\n\n    \nbool\n \nheader_override_defaults\n;\n\n\n    \nquiet_checksum_scheme_t\n \nheader_checksum_scheme\n;\n\n\n    \nquiet_error_correction_scheme_t\n \nheader_inner_fec_scheme\n;\n\n\n    \nquiet_error_correction_scheme_t\n \nheader_outer_fec_scheme\n;\n\n\n    \nquiet_modulation_scheme_t\n \nheader_mod_scheme\n;\n\n\n    \nsize_t\n \nframe_len\n;\n\n\n\n}\n \nquiet_encoder_options\n;\n\n\n\n\n\n\nThis specifies a complete set of options for the encoder in libquiet.\n\n\nofdmopt\n\n\nOFDM options, used only by OFDM mode.\n\n\nmodopt\n\n\nInterpolation filter and carrier frequency options.\n\n\nresampler\n\n\nResampler configuration (if specified frequency is not 44.1kHz)\n\n\nencoding\n\n\nEncoder mode, one of {ofdm_encoding, modem_encoding, gmsk_encoding}.\n\n\nchecksum_scheme\n\n\ninner_fec_scheme\n\n\nouter_fec_scheme\n\n\nmod_scheme\n\n\nheader_override_defaults\n\n\nHeader schemes These control the frame header properties Only used if header_override_defaults = true.\n\n\nheader_checksum_scheme\n\n\nheader_inner_fec_scheme\n\n\nheader_outer_fec_scheme\n\n\nheader_mod_scheme\n\n\nframe_len\n\n\nMaximum frame length.\n\n\nThis value controls the maximum length of the user-controlled section of the frame. There is overhead in starting new frames, and each frame performs its own CRC check which either accepts or rejects the frame. A frame begins with a synchronization section which the decoder uses to detect and lock on to the frame. Over time, the synchronization will drift, which makes shorter frames easier to decode than longer frames.\n\n\nquiet_decoder_options\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nquiet_ofdm_options\n \nofdmopt\n;\n\n\n    \nquiet_demodulator_options\n \ndemodopt\n;\n\n\n    \nquiet_resampler_options\n \nresampler\n;\n\n\n    \nquiet_encoding_t\n \nencoding\n;\n\n\n    \nbool\n \nheader_override_defaults\n;\n\n\n    \nquiet_checksum_scheme_t\n \nheader_checksum_scheme\n;\n\n\n    \nquiet_error_correction_scheme_t\n \nheader_inner_fec_scheme\n;\n\n\n    \nquiet_error_correction_scheme_t\n \nheader_outer_fec_scheme\n;\n\n\n    \nquiet_modulation_scheme_t\n \nheader_mod_scheme\n;\n\n\n    \nbool\n \nis_debug\n;\n\n\n\n}\n \nquiet_decoder_options\n;\n\n\n\n\n\n\nThis specifies a complete set of options for the decoder in libquiet.\n\n\nIn order for a decoder to decode the signals from an encoder, certain options must match between both. In particular, the encoding mode and modopt/demodopt must match. Additionally, if ofdm_encoding is used, then the ofdmopt must also match. If the header options are overriden in the encoder, then they must also be overriden in the decoder.\n\n\nofdmopt\n\n\nOFDM options, used only by OFDM mode.\n\n\ndemodopt\n\n\nDecimation filter and carrier frequency options.\n\n\nresampler\n\n\nResampler configuration (if specified frequency is not 44.1kHz)\n\n\nencoding\n\n\nEncoder mode, one of {ofdm_encoding, modem_encoding, gmsk_encoding}.\n\n\nheader_override_defaults\n\n\nHeader schemes These control the frame header properties Only used if header_override_defaults = true.\n\n\nheader_checksum_scheme\n\n\nheader_inner_fec_scheme\n\n\nheader_outer_fec_scheme\n\n\nheader_mod_scheme\n\n\nis_debug\n\n\nEnable debug mode on receiver.\n\n\nIn order for this flag to work, libquiet must be compiled in debug mode (\n#define QUIET_DEBUG 1\n). Once enabled, this mode causes the decoder to use liquid to create debug files which can be viewed in matlab/octave. These files have the filename format framesync_d, where d is an increasing number. These files can be useful for tracking the decoder's behavior.\n\n\nquiet_modulator_options\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nint\n \nshape\n;\n\n\n    \nunsigned\n \nint\n \nsamples_per_symbol\n;\n\n\n    \nunsigned\n \nint\n \nsymbol_delay\n;\n\n\n    \nfloat\n \nexcess_bw\n;\n\n\n    \nfloat\n \ncenter_rads\n;\n\n\n    \nfloat\n \ngain\n;\n\n\n    \nquiet_dc_filter_options\n \ndc_filter_opt\n;\n\n\n\n}\n \nquiet_modulator_options\n;\n\n\n\n\n\n\nThis set of options is used only by the encoder\n\n\nThe modulator is a combination element which interpolates the encoded signal (rescaling in frequency domain) and then mixes it onto a carrier of a given frequency. Finally, a gain is applied, and an optional DC blocker removes DC components.\n\n\nshape\n\n\nNumerical value for shape of interpolation filter.\n\n\nThese values correspond to those used by liquid DSP. In particular,\n\n\n1: Nyquist Kaiser\n\n\n2: Parks-McClellan\n\n\n3: Raised Cosine\n\n\n4: Flipped Exponential (Nyquist)\n\n\n5: Flipped Hyperbolic Secant (Nyquist)\n\n\n6: Flipped Arc-Hyperbolic Secant (Nyquist)\n\n\n7: Root-Nyquist Kaiser (Approximate Optimum)\n\n\n8: Root-Nyquist Kaiser (True Optimum)\n\n\n9: Root Raised Cosine\n\n\n10: Harris-Moerder-3\n\n\n11: GMSK Transmit\n\n\n12: GMSK Receive\n\n\n13: Flipped Exponential (root-Nyquist)\n\n\n14: Flipped Hyperbolic Secant (root-Nyquist)\n\n\n15: Flipped Arc-Hyperbolic Secant (root-Nyquist)\n\n\nAll other values invalid\n\n\nsamples_per_symbol\n\n\ninterpolation factor\n\n\nsymbol_delay\n\n\ninterpolation filter delay\n\n\nexcess_bw\n\n\ninterpolation roll-off factor\n\n\ncenter_rads\n\n\ncarrier frequency, [0, 2*pi)\n\n\ngain\n\n\ngain, [0, 0.5]\n\n\ndc_filter_opt\n\n\ndc blocker options\n\n\nquiet_demodulator_options\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nint\n \nshape\n;\n\n\n    \nunsigned\n \nint\n \nsamples_per_symbol\n;\n\n\n    \nunsigned\n \nint\n \nsymbol_delay\n;\n\n\n    \nfloat\n \nexcess_bw\n;\n\n\n    \nfloat\n \ncenter_rads\n;\n\n\n\n}\n \nquiet_demodulator_options\n;\n\n\n\n\n\n\nThis set of options is used only by the decoder\n\n\nThe demodulator is a combination element which inverts the operations of the modulator. It first mixes down from the carrier and then performs decimation to recover the signal.\n\n\nshape\n\n\nNumerical value for shape of decimation filter.\n\n\nThis uses the same set of values as \nquiet_modulator_options.shape\n\n\nsamples_per_symbol\n\n\ndecimation factor\n\n\nsymbol_delay\n\n\ndecimation filter delay\n\n\nexcess_bw\n\n\ndecimation roll-off factor\n\n\ncenter_rads\n\n\ncarrier frequency, [0, 2*pi)\n\n\nquiet_encoding_t\n\n\ntypedef\n \nenum\n \n{\n\n\n    \nofdm_encoding\n,\n\n\n    \nmodem_encoding\n,\n\n\n    \ngmsk_encoding\n\n\n\n}\n \nquiet_encoding_t\n;\n\n\n\n\n\n\nSelects operational mode for encoder/decoder. OFDM and Modem mode use the same modulation schemes while gmsk ignores the supplied scheme and uses its own\n\n\nofdm_encoding\n\n\nEncode/decode in OFDM mode.\n\n\nmodem_encoding\n\n\nEncode/decode in modem mode.\n\n\ngmsk_encoding\n\n\nEncode/decode in gaussian minimum shift keying mode.\n\n\nGMSK mode does not offer the modulation modes given by the other encodings. It has a fairly limited bitrate, but the advantage of GMSK is that its receiver does not need to compute any FFTs, making it suitable for low-power receivers or situations with little computational capacity.\n\n\nquiet_ofdm_options\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nunsigned\n \nint\n \nnum_subcarriers\n;\n\n\n    \nunsigned\n \nint\n \ncyclic_prefix_len\n;\n\n\n    \nunsigned\n \nint\n \ntaper_len\n;\n\n\n    \nsize_t\n \nleft_band\n;\n\n\n    \nsize_t\n \nright_band\n;\n\n\n\n}\n \nquiet_ofdm_options\n;\n\n\n\n\n\n\nThese options configure the behavior of OFDM, orthogonal frequency division multiplexing, as used by the encoder. OFDM places the modulated symbols on to multiple orthogonal subcarriers. This can help the decoder estabilish good equalization when used on a system with uneven filtering.\n\n\nnum_subcarriers\n\n\ntotal number of subcarriers used, inlcuding guard bands and pilots\n\n\ncyclic_prefix_len\n\n\nnumber of cyclic prefix samples between symbols\n\n\ntaper_len\n\n\nnumber of taper window between symbols\n\n\nleft_band\n\n\nnumber of extra guard subcarriers inserted on left (low freq)\n\n\nright_band\n\n\nnumber of extra guard subcarriers inserted on right (high freq)\n\n\nquiet_checksum_scheme_t\n\n\ntypedef\n \nenum\n \n{\n\n\n    \nquiet_checksum_none\n \n=\n \n1\n,\n\n\n    \nquiet_checksum_8bit\n,\n\n\n    \nquiet_checksum_crc8\n,\n\n\n    \nquiet_checksum_crc16\n,\n\n\n    \nquiet_checksum_crc24\n,\n\n\n    \nquiet_checksum_crc32\n\n\n\n}\n \nquiet_checksum_scheme_t\n;\n\n\n\n\n\n\nquiet_checksum_none\n\n\nno error-detection\n\n\nquiet_checksum_8bit\n\n\n8-bit checksum\n\n\nquiet_checksum_crc8\n\n\n8-bit CRC\n\n\nquiet_checksum_crc16\n\n\n16-bit CRC\n\n\nquiet_checksum_crc24\n\n\n24-bit CRC\n\n\nquiet_checksum_crc32\n\n\n32-bit CRC\n\n\nquiet_error_correction_scheme_t\n\n\ntypedef\n \nenum\n \n{\n\n\n    \nquiet_error_correction_none\n \n=\n \n1\n,\n\n\n    \nquiet_error_correction_repeat_3\n,\n\n\n    \nquiet_error_correction_repeat_5\n,\n\n\n    \nquiet_error_correction_hamming_7_4\n,\n\n\n    \nquiet_error_correction_hamming_7_4_parity\n,\n\n\n    \nquiet_error_correction_hamming_12_8\n,\n\n\n    \nquiet_error_correction_golay_24_12\n,\n\n\n    \nquiet_error_correction_secded_22_16\n,\n\n\n    \nquiet_error_correction_secded_39_32\n,\n\n\n    \nquiet_error_correction_secded_72_64\n,\n\n\n    \nquiet_error_correction_conv_12_7\n,\n\n\n    \nquiet_error_correction_conv_12_9\n,\n\n\n    \nquiet_error_correction_conv_13_9\n,\n\n\n    \nquiet_error_correction_conv_16_15\n,\n\n\n    \nquiet_error_correction_conv_perf_23_7\n,\n\n\n    \nquiet_error_correction_conv_perf_34_7\n,\n\n\n    \nquiet_error_correction_conv_perf_45_7\n,\n\n\n    \nquiet_error_correction_conv_perf_56_7\n,\n\n\n    \nquiet_error_correction_conv_perf_67_7\n,\n\n\n    \nquiet_error_correction_conv_perf_78_7\n,\n\n\n    \nquiet_error_correction_conv_perf_23_9\n,\n\n\n    \nquiet_error_correction_conv_perf_34_9\n,\n\n\n    \nquiet_error_correction_conv_perf_45_9\n,\n\n\n    \nquiet_error_correction_conv_perf_56_9\n,\n\n\n    \nquiet_error_correction_conv_perf_67_9\n,\n\n\n    \nquiet_error_correction_conv_perf_78_9\n,\n\n\n    \nquiet_error_correction_reed_solomon_223_255\n\n\n\n}\n \nquiet_error_correction_scheme_t\n;\n\n\n\n\n\n\nquiet_error_correction_none\n\n\nno error-correction\n\n\nquiet_error_correction_repeat_3\n\n\nsimple repeat code, r1/3\n\n\nquiet_error_correction_repeat_5\n\n\nsimple repeat code, r1/5\n\n\nquiet_error_correction_hamming_7_4\n\n\nHamming (7,4) block code, r1/2 (really 4/7)\n\n\nquiet_error_correction_hamming_7_4_parity\n\n\nHamming (7,4) with extra parity bit, r1/2.\n\n\nquiet_error_correction_hamming_12_8\n\n\nHamming (12,8) block code, r2/3.\n\n\nquiet_error_correction_golay_24_12\n\n\nGolay (24,12) block code, r1/2.\n\n\nquiet_error_correction_secded_22_16\n\n\nSEC-DED (22,16) block code, r8/11.\n\n\nquiet_error_correction_secded_39_32\n\n\nSEC-DED (39,32) block code.\n\n\nquiet_error_correction_secded_72_64\n\n\nSEC-DED (72,64) block code, r8/9.\n\n\nquiet_error_correction_conv_12_7\n\n\nconvolutional code r1/2, K=7, dfree=10\n\n\nquiet_error_correction_conv_12_9\n\n\nconvolutional code r1/2, K=9, dfree=12\n\n\nquiet_error_correction_conv_13_9\n\n\nconvolutional code r1/3, K=9, dfree=18\n\n\nquiet_error_correction_conv_16_15\n\n\nconvolutional code 1/6, K=15, dfree\n=57 (Heller 1968)\n\n\nquiet_error_correction_conv_perf_23_7\n\n\nperforated convolutional code r2/3, K=7, dfree=6\n\n\nquiet_error_correction_conv_perf_34_7\n\n\nperforated convolutional code r3/4, K=7, dfree=5\n\n\nquiet_error_correction_conv_perf_45_7\n\n\nperforated convolutional code r4/5, K=7, dfree=4\n\n\nquiet_error_correction_conv_perf_56_7\n\n\nperforated convolutional code r5/6, K=7, dfree=4\n\n\nquiet_error_correction_conv_perf_67_7\n\n\nperforated convolutional code r6/7, K=7, dfree=3\n\n\nquiet_error_correction_conv_perf_78_7\n\n\nperforated convolutional code r7/8, K=7, dfree=3\n\n\nquiet_error_correction_conv_perf_23_9\n\n\nperforated convolutional code r2/3, K=9, dfree=7\n\n\nquiet_error_correction_conv_perf_34_9\n\n\nperforated convolutional code r3/4, K=9, dfree=6\n\n\nquiet_error_correction_conv_perf_45_9\n\n\nperforated convolutional code r4/5, K=9, dfree=5\n\n\nquiet_error_correction_conv_perf_56_9\n\n\nperforated convolutional code r5/6, K=9, dfree=5\n\n\nquiet_error_correction_conv_perf_67_9\n\n\nperforated convolutional code r6/7, K=9, dfree=4\n\n\nquiet_error_correction_conv_perf_78_9\n\n\nperforated convolutional code r7/8, K=9, dfree=4\n\n\nquiet_error_correction_reed_solomon_223_255\n\n\nReed-Solomon m=8, n=255, k=223.\n\n\nquiet_modulation_scheme_t\n\n\ntypedef\n \nenum\n \n{\n\n\n    \nquiet_modulation_psk2\n \n=\n \n1\n,\n\n\n    \nquiet_modulation_psk4\n,\n\n\n    \nquiet_modulation_psk8\n,\n\n\n    \nquiet_modulation_psk16\n,\n\n\n    \nquiet_modulation_psk32\n,\n\n\n    \nquiet_modulation_psk64\n,\n\n\n    \nquiet_modulation_psk128\n,\n\n\n    \nquiet_modulation_psk256\n,\n\n\n    \nquiet_modulation_dpsk2\n,\n\n\n    \nquiet_modulation_dpsk4\n,\n\n\n    \nquiet_modulation_dpsk8\n,\n\n\n    \nquiet_modulation_dpsk16\n,\n\n\n    \nquiet_modulation_dpsk32\n,\n\n\n    \nquiet_modulation_dpsk64\n,\n\n\n    \nquiet_modulation_dpsk128\n,\n\n\n    \nquiet_modulation_dpsk256\n,\n\n\n    \nquiet_modulation_ask2\n,\n\n\n    \nquiet_modulation_ask4\n,\n\n\n    \nquiet_modulation_ask8\n,\n\n\n    \nquiet_modulation_ask16\n,\n\n\n    \nquiet_modulation_ask32\n,\n\n\n    \nquiet_modulation_ask64\n,\n\n\n    \nquiet_modulation_ask128\n,\n\n\n    \nquiet_modulation_ask256\n,\n\n\n    \nquiet_modulation_qask4\n,\n\n\n    \nquiet_modulation_qask8\n,\n\n\n    \nquiet_modulation_qask16\n,\n\n\n    \nquiet_modulation_qask32\n,\n\n\n    \nquiet_modulation_qask64\n,\n\n\n    \nquiet_modulation_qask128\n,\n\n\n    \nquiet_modulation_qask256\n,\n\n\n    \nquiet_modulation_qask512\n,\n\n\n    \nquiet_modulation_qask1024\n,\n\n\n    \nquiet_modulation_qask2048\n,\n\n\n    \nquiet_modulation_qask4096\n,\n\n\n    \nquiet_modulation_qask8192\n,\n\n\n    \nquiet_modulation_qask16384\n,\n\n\n    \nquiet_modulation_qask32768\n,\n\n\n    \nquiet_modulation_qask65536\n,\n\n\n    \nquiet_modulation_apsk4\n,\n\n\n    \nquiet_modulation_apsk8\n,\n\n\n    \nquiet_modulation_apsk16\n,\n\n\n    \nquiet_modulation_apsk32\n,\n\n\n    \nquiet_modulation_apsk64\n,\n\n\n    \nquiet_modulation_apsk128\n,\n\n\n    \nquiet_modulation_apsk256\n,\n\n\n    \nquiet_modulation_bpsk\n,\n\n\n    \nquiet_modulation_qpsk\n,\n\n\n    \nquiet_modulation_ook\n,\n\n\n    \nquiet_modulation_sqask32\n,\n\n\n    \nquiet_modulation_sqask128\n,\n\n\n    \nquiet_modulation_v29\n,\n\n\n    \nquiet_modulation_opt_qask16\n,\n\n\n    \nquiet_modulation_opt_qask32\n,\n\n\n    \nquiet_modulation_opt_qask64\n,\n\n\n    \nquiet_modulation_opt_qask128\n,\n\n\n    \nquiet_modulation_opt_qask256\n,\n\n\n    \nquiet_modulation_vtech\n\n\n\n}\n \nquiet_modulation_scheme_t\n;\n\n\n\n\n\n\nquiet_modulation_psk2\n\n\nphase-shift keying-2\n\n\nquiet_modulation_psk4\n\n\nphase-shift keying-4\n\n\nquiet_modulation_psk8\n\n\nphase-shift keying-8\n\n\nquiet_modulation_psk16\n\n\nphase-shift keying-16\n\n\nquiet_modulation_psk32\n\n\nphase-shift keying-32\n\n\nquiet_modulation_psk64\n\n\nphase-shift keying-64\n\n\nquiet_modulation_psk128\n\n\nphase-shift keying-128\n\n\nquiet_modulation_psk256\n\n\nphase-shift keying-256\n\n\nquiet_modulation_dpsk2\n\n\ndifferential phase-shift keying-2\n\n\nquiet_modulation_dpsk4\n\n\ndifferential phase-shift keying-4\n\n\nquiet_modulation_dpsk8\n\n\ndifferential phase-shift keying-8\n\n\nquiet_modulation_dpsk16\n\n\ndifferential phase-shift keying-16\n\n\nquiet_modulation_dpsk32\n\n\ndifferential phase-shift keying-32\n\n\nquiet_modulation_dpsk64\n\n\ndifferential phase-shift keying-64\n\n\nquiet_modulation_dpsk128\n\n\ndifferential phase-shift keying-128\n\n\nquiet_modulation_dpsk256\n\n\ndifferential phase-shift keying-256\n\n\nquiet_modulation_ask2\n\n\namplitude-shift keying-2\n\n\nquiet_modulation_ask4\n\n\namplitude-shift keying-4\n\n\nquiet_modulation_ask8\n\n\namplitude-shift keying-8\n\n\nquiet_modulation_ask16\n\n\namplitude-shift keying-16\n\n\nquiet_modulation_ask32\n\n\namplitude-shift keying-32\n\n\nquiet_modulation_ask64\n\n\namplitude-shift keying-64\n\n\nquiet_modulation_ask128\n\n\namplitude-shift keying-128\n\n\nquiet_modulation_ask256\n\n\namplitude-shift keying-256\n\n\nquiet_modulation_qask4\n\n\nquadrature amplitude-shift keying-4\n\n\nquiet_modulation_qask8\n\n\nquadrature amplitude-shift keying-8\n\n\nquiet_modulation_qask16\n\n\nquadrature amplitude-shift keying-16\n\n\nquiet_modulation_qask32\n\n\nquadrature amplitude-shift keying-32\n\n\nquiet_modulation_qask64\n\n\nquadrature amplitude-shift keying-64\n\n\nquiet_modulation_qask128\n\n\nquadrature amplitude-shift keying-128\n\n\nquiet_modulation_qask256\n\n\nquadrature amplitude-shift keying-256\n\n\nquiet_modulation_qask512\n\n\nquadrature amplitude-shift keying-512\n\n\nquiet_modulation_qask1024\n\n\nquadrature amplitude-shift keying-1024\n\n\nquiet_modulation_qask2048\n\n\nquadrature amplitude-shift keying-2048\n\n\nquiet_modulation_qask4096\n\n\nquadrature amplitude-shift keying-4096\n\n\nquiet_modulation_qask8192\n\n\nquadrature amplitude-shift keying-8192\n\n\nquiet_modulation_qask16384\n\n\nquadrature amplitude-shift keying-16384\n\n\nquiet_modulation_qask32768\n\n\nquadrature amplitude-shift keying-32768\n\n\nquiet_modulation_qask65536\n\n\nquadrature amplitude-shift keying-65536\n\n\nquiet_modulation_apsk4\n\n\namplitude phase-shift keying-4\n\n\nquiet_modulation_apsk8\n\n\namplitude phase-shift keying-8\n\n\nquiet_modulation_apsk16\n\n\namplitude phase-shift keying-16\n\n\nquiet_modulation_apsk32\n\n\namplitude phase-shift keying-32\n\n\nquiet_modulation_apsk64\n\n\namplitude phase-shift keying-64\n\n\nquiet_modulation_apsk128\n\n\namplitude phase-shift keying-128\n\n\nquiet_modulation_apsk256\n\n\namplitude phase-shift keying-256\n\n\nquiet_modulation_bpsk\n\n\nbinary phase-shift keying\n\n\nquiet_modulation_qpsk\n\n\nquaternary phase-shift keying\n\n\nquiet_modulation_ook\n\n\non-off keying\n\n\nquiet_modulation_sqask32\n\n\nsquare quadrature amplitude-shift keying-32\n\n\nquiet_modulation_sqask128\n\n\nsquare quadrature amplitude-shift keying-128\n\n\nquiet_modulation_v29\n\n\nV.29 star constellation.\n\n\nquiet_modulation_opt_qask16\n\n\noptimal quadrature amplitude-shift keying-16\n\n\nquiet_modulation_opt_qask32\n\n\noptimal quadrature amplitude-shift keying-32\n\n\nquiet_modulation_opt_qask64\n\n\noptimal quadrature amplitude-shift keying-64\n\n\nquiet_modulation_opt_qask128\n\n\noptimal quadrature amplitude-shift keying-128\n\n\nquiet_modulation_opt_qask256\n\n\noptimal quadrature amplitude-shift keying-256\n\n\nquiet_modulation_vtech\n\n\nVirginia Tech logo constellation.\n\n\nquiet_dc_filter_options\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nfloat\n \nalpha\n;\n\n\n\n}\n \nquiet_dc_filter_options\n;\n\n\n\n\n\n\nThis DC blocker is applied near the end of the signal chain so that any leftover DC component is removed. This is important for audio signals as we do not want to send any DC out to speakers\n\n\ntransfer function H(z)=(1 - (z^-1))/(1 - (1-alpha)*(z^-1))\n\n\nalpha\n\n\nquiet_resampler_options\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nsize_t\n \ndelay\n;\n\n\n    \nfloat\n \nbandwidth\n;\n\n\n    \nfloat\n \nattenuation\n;\n\n\n    \nsize_t\n \nfilter_bank_size\n;\n\n\n\n}\n \nquiet_resampler_options\n;\n\n\n\n\n\n\nControls arbitrary resample unit used by libquiet after generating 44.1kHz signal or before decoding signal\n\n\nThis resampler will be applied to set the sample rate to the rate given when creating an encoder or decoder\n\n\ndelay\n\n\nbandwidth\n\n\nattenuation\n\n\nfilter_bank_size", 
            "title": "Modem Configuration"
        }, 
        {
            "location": "/configuration/#modem-configuration", 
            "text": "The primary configuration structures for libquiet are  quiet_encoder_options  and  quiet_decoder_options . Although it is possible to modify values in these structures, it is generally recommended to use the JSON-based configuration system instead, as that system works consistently across all platforms. This page documents how to configure from the JSON profiles as well as the raw configuration structures themselves.", 
            "title": "Modem Configuration"
        }, 
        {
            "location": "/configuration/#quiet_decoder_profile_file", 
            "text": "quiet_decoder_options   *  quiet_decoder_profile_file ( FILE   * f , \n\n                            const   char   * profilename );   libquiet's configuration options are fairly numerous, and testing can be frustrating when configuration requires recompilation. For this reason, libquiet provides a JSON file containing multiple sets of configuration  profiles  and functions to read and validate them.  Each profile provides access to every option contained in quiet_encoder_options/quiet_decoder_options. It is hoped that this will give good default options and provide a starting place for users to tune new profiles.  quiet_decoder_profile_file reads the profile given by profilename from the file pointer and returns the corresponding  quiet_decoder_options .", 
            "title": "quiet_decoder_profile_file"
        }, 
        {
            "location": "/configuration/#parameters", 
            "text": "f  - file pointer which contains a valid JSON libquiet profile set  profilename  - the string key of the profile to fetch", 
            "title": "Parameters"
        }, 
        {
            "location": "/configuration/#returns", 
            "text": "a pointer to an initialized  quiet_decoder_options  or NULL if decoding failed. must be freed by caller (with free()).", 
            "title": "Returns"
        }, 
        {
            "location": "/configuration/#quiet_decoder_profile_filename", 
            "text": "quiet_decoder_options   *  quiet_decoder_profile_filename ( const   char   * fname , \n\n                                const   char   * profilename );   quiet_decoder_profile_filename reads the profile given by profilename from the file located at filename and returns the corresponding  quiet_decoder_options .", 
            "title": "quiet_decoder_profile_filename"
        }, 
        {
            "location": "/configuration/#parameters_1", 
            "text": "fname  - path to a file which will be opened and read, must contain a valid JSON liquiet profile set  profilename  - the string key of the profile to fetch", 
            "title": "Parameters"
        }, 
        {
            "location": "/configuration/#returns_1", 
            "text": "a pointer to an initialized  quiet_decoder_options  or NULL if decoding failed. must be freed by caller (with free()).", 
            "title": "Returns"
        }, 
        {
            "location": "/configuration/#quiet_decoder_profile_str", 
            "text": "quiet_decoder_options   *  quiet_decoder_profile_str ( const   char   * input , \n\n                           const   char   * profilename );   quiet_decoder_profile_str reads the profile given by profilename from the input and returns the corresponding  quiet_decoder_options .", 
            "title": "quiet_decoder_profile_str"
        }, 
        {
            "location": "/configuration/#parameters_2", 
            "text": "input  - a string containing a valid JSON libquiet profile set  profilename  - the string key of the profile to fetch", 
            "title": "Parameters"
        }, 
        {
            "location": "/configuration/#returns_2", 
            "text": "a pointer to an initialized  quiet_decoder_options  or NULL if decoding failed. must be freed by caller (with free()).", 
            "title": "Returns"
        }, 
        {
            "location": "/configuration/#quiet_encoder_profile_file", 
            "text": "quiet_encoder_options   *  quiet_encoder_profile_file ( FILE   * f , \n\n                            const   char   * profilename );   quiet_encoder_profile_file reads the profile given by profilename from the file pointer and returns the corresponding  quiet_encoder_options .", 
            "title": "quiet_encoder_profile_file"
        }, 
        {
            "location": "/configuration/#parameters_3", 
            "text": "f  - file pointer which contains a valid JSON libquiet profile set  profilename  - the string key of the profile to fetch", 
            "title": "Parameters"
        }, 
        {
            "location": "/configuration/#returns_3", 
            "text": "a pointer to an initialized  quiet_encoder_options  or NULL if decoding failed. must be freed by caller (with free()).", 
            "title": "Returns"
        }, 
        {
            "location": "/configuration/#quiet_encoder_profile_filename", 
            "text": "quiet_encoder_options   *  quiet_encoder_profile_filename ( const   char   * fname , \n\n                                const   char   * profilename );   quiet_encoder_profile_filename reads the profile given by profilename from the file located at filename and returns the corresponding  quiet_encoder_options .", 
            "title": "quiet_encoder_profile_filename"
        }, 
        {
            "location": "/configuration/#parameters_4", 
            "text": "fname  - path to a file which will be opened and read, must contain a valid JSON liquiet profile set  profilename  - the string key of the profile to fetch", 
            "title": "Parameters"
        }, 
        {
            "location": "/configuration/#returns_4", 
            "text": "a pointer to an initialized  quiet_encoder_options  or NULL if decoding failed. must be freed by caller (with free()).", 
            "title": "Returns"
        }, 
        {
            "location": "/configuration/#quiet_encoder_profile_str", 
            "text": "quiet_encoder_options   *  quiet_encoder_profile_str ( const   char   * input , \n\n                           const   char   * profilename );   quiet_encoder_profile_str reads the profile given by profilename from the input and returns the corresponding  quiet_encoder_options .", 
            "title": "quiet_encoder_profile_str"
        }, 
        {
            "location": "/configuration/#parameters_5", 
            "text": "input  - a string containing a valid JSON libquiet profile set  profilename  - the string key of the profile to fetch", 
            "title": "Parameters"
        }, 
        {
            "location": "/configuration/#returns_5", 
            "text": "a pointer to an initialized  quiet_encoder_options  or NULL if decoding failed. must be freed by caller (with free()).", 
            "title": "Returns"
        }, 
        {
            "location": "/configuration/#quiet_encoder_options", 
            "text": "typedef   struct   { \n\n     quiet_ofdm_options   ofdmopt ; \n\n     quiet_modulator_options   modopt ; \n\n     quiet_resampler_options   resampler ; \n\n     quiet_encoding_t   encoding ; \n\n     quiet_checksum_scheme_t   checksum_scheme ; \n\n     quiet_error_correction_scheme_t   inner_fec_scheme ; \n\n     quiet_error_correction_scheme_t   outer_fec_scheme ; \n\n     quiet_modulation_scheme_t   mod_scheme ; \n\n     bool   header_override_defaults ; \n\n     quiet_checksum_scheme_t   header_checksum_scheme ; \n\n     quiet_error_correction_scheme_t   header_inner_fec_scheme ; \n\n     quiet_error_correction_scheme_t   header_outer_fec_scheme ; \n\n     quiet_modulation_scheme_t   header_mod_scheme ; \n\n     size_t   frame_len ;  }   quiet_encoder_options ;   This specifies a complete set of options for the encoder in libquiet.", 
            "title": "quiet_encoder_options"
        }, 
        {
            "location": "/configuration/#ofdmopt", 
            "text": "OFDM options, used only by OFDM mode.", 
            "title": "ofdmopt"
        }, 
        {
            "location": "/configuration/#modopt", 
            "text": "Interpolation filter and carrier frequency options.", 
            "title": "modopt"
        }, 
        {
            "location": "/configuration/#resampler", 
            "text": "Resampler configuration (if specified frequency is not 44.1kHz)", 
            "title": "resampler"
        }, 
        {
            "location": "/configuration/#encoding", 
            "text": "Encoder mode, one of {ofdm_encoding, modem_encoding, gmsk_encoding}.", 
            "title": "encoding"
        }, 
        {
            "location": "/configuration/#checksum_scheme", 
            "text": "", 
            "title": "checksum_scheme"
        }, 
        {
            "location": "/configuration/#inner_fec_scheme", 
            "text": "", 
            "title": "inner_fec_scheme"
        }, 
        {
            "location": "/configuration/#outer_fec_scheme", 
            "text": "", 
            "title": "outer_fec_scheme"
        }, 
        {
            "location": "/configuration/#mod_scheme", 
            "text": "", 
            "title": "mod_scheme"
        }, 
        {
            "location": "/configuration/#header_override_defaults", 
            "text": "Header schemes These control the frame header properties Only used if header_override_defaults = true.", 
            "title": "header_override_defaults"
        }, 
        {
            "location": "/configuration/#header_checksum_scheme", 
            "text": "", 
            "title": "header_checksum_scheme"
        }, 
        {
            "location": "/configuration/#header_inner_fec_scheme", 
            "text": "", 
            "title": "header_inner_fec_scheme"
        }, 
        {
            "location": "/configuration/#header_outer_fec_scheme", 
            "text": "", 
            "title": "header_outer_fec_scheme"
        }, 
        {
            "location": "/configuration/#header_mod_scheme", 
            "text": "", 
            "title": "header_mod_scheme"
        }, 
        {
            "location": "/configuration/#frame_len", 
            "text": "Maximum frame length.  This value controls the maximum length of the user-controlled section of the frame. There is overhead in starting new frames, and each frame performs its own CRC check which either accepts or rejects the frame. A frame begins with a synchronization section which the decoder uses to detect and lock on to the frame. Over time, the synchronization will drift, which makes shorter frames easier to decode than longer frames.", 
            "title": "frame_len"
        }, 
        {
            "location": "/configuration/#quiet_decoder_options", 
            "text": "typedef   struct   { \n\n     quiet_ofdm_options   ofdmopt ; \n\n     quiet_demodulator_options   demodopt ; \n\n     quiet_resampler_options   resampler ; \n\n     quiet_encoding_t   encoding ; \n\n     bool   header_override_defaults ; \n\n     quiet_checksum_scheme_t   header_checksum_scheme ; \n\n     quiet_error_correction_scheme_t   header_inner_fec_scheme ; \n\n     quiet_error_correction_scheme_t   header_outer_fec_scheme ; \n\n     quiet_modulation_scheme_t   header_mod_scheme ; \n\n     bool   is_debug ;  }   quiet_decoder_options ;   This specifies a complete set of options for the decoder in libquiet.  In order for a decoder to decode the signals from an encoder, certain options must match between both. In particular, the encoding mode and modopt/demodopt must match. Additionally, if ofdm_encoding is used, then the ofdmopt must also match. If the header options are overriden in the encoder, then they must also be overriden in the decoder.", 
            "title": "quiet_decoder_options"
        }, 
        {
            "location": "/configuration/#ofdmopt_1", 
            "text": "OFDM options, used only by OFDM mode.", 
            "title": "ofdmopt"
        }, 
        {
            "location": "/configuration/#demodopt", 
            "text": "Decimation filter and carrier frequency options.", 
            "title": "demodopt"
        }, 
        {
            "location": "/configuration/#resampler_1", 
            "text": "Resampler configuration (if specified frequency is not 44.1kHz)", 
            "title": "resampler"
        }, 
        {
            "location": "/configuration/#encoding_1", 
            "text": "Encoder mode, one of {ofdm_encoding, modem_encoding, gmsk_encoding}.", 
            "title": "encoding"
        }, 
        {
            "location": "/configuration/#header_override_defaults_1", 
            "text": "Header schemes These control the frame header properties Only used if header_override_defaults = true.", 
            "title": "header_override_defaults"
        }, 
        {
            "location": "/configuration/#header_checksum_scheme_1", 
            "text": "", 
            "title": "header_checksum_scheme"
        }, 
        {
            "location": "/configuration/#header_inner_fec_scheme_1", 
            "text": "", 
            "title": "header_inner_fec_scheme"
        }, 
        {
            "location": "/configuration/#header_outer_fec_scheme_1", 
            "text": "", 
            "title": "header_outer_fec_scheme"
        }, 
        {
            "location": "/configuration/#header_mod_scheme_1", 
            "text": "", 
            "title": "header_mod_scheme"
        }, 
        {
            "location": "/configuration/#is_debug", 
            "text": "Enable debug mode on receiver.  In order for this flag to work, libquiet must be compiled in debug mode ( #define QUIET_DEBUG 1 ). Once enabled, this mode causes the decoder to use liquid to create debug files which can be viewed in matlab/octave. These files have the filename format framesync_d, where d is an increasing number. These files can be useful for tracking the decoder's behavior.", 
            "title": "is_debug"
        }, 
        {
            "location": "/configuration/#quiet_modulator_options", 
            "text": "typedef   struct   { \n\n     unsigned   int   shape ; \n\n     unsigned   int   samples_per_symbol ; \n\n     unsigned   int   symbol_delay ; \n\n     float   excess_bw ; \n\n     float   center_rads ; \n\n     float   gain ; \n\n     quiet_dc_filter_options   dc_filter_opt ;  }   quiet_modulator_options ;   This set of options is used only by the encoder  The modulator is a combination element which interpolates the encoded signal (rescaling in frequency domain) and then mixes it onto a carrier of a given frequency. Finally, a gain is applied, and an optional DC blocker removes DC components.", 
            "title": "quiet_modulator_options"
        }, 
        {
            "location": "/configuration/#shape", 
            "text": "Numerical value for shape of interpolation filter.  These values correspond to those used by liquid DSP. In particular,  1: Nyquist Kaiser  2: Parks-McClellan  3: Raised Cosine  4: Flipped Exponential (Nyquist)  5: Flipped Hyperbolic Secant (Nyquist)  6: Flipped Arc-Hyperbolic Secant (Nyquist)  7: Root-Nyquist Kaiser (Approximate Optimum)  8: Root-Nyquist Kaiser (True Optimum)  9: Root Raised Cosine  10: Harris-Moerder-3  11: GMSK Transmit  12: GMSK Receive  13: Flipped Exponential (root-Nyquist)  14: Flipped Hyperbolic Secant (root-Nyquist)  15: Flipped Arc-Hyperbolic Secant (root-Nyquist)  All other values invalid", 
            "title": "shape"
        }, 
        {
            "location": "/configuration/#samples_per_symbol", 
            "text": "interpolation factor", 
            "title": "samples_per_symbol"
        }, 
        {
            "location": "/configuration/#symbol_delay", 
            "text": "interpolation filter delay", 
            "title": "symbol_delay"
        }, 
        {
            "location": "/configuration/#excess_bw", 
            "text": "interpolation roll-off factor", 
            "title": "excess_bw"
        }, 
        {
            "location": "/configuration/#center_rads", 
            "text": "carrier frequency, [0, 2*pi)", 
            "title": "center_rads"
        }, 
        {
            "location": "/configuration/#gain", 
            "text": "gain, [0, 0.5]", 
            "title": "gain"
        }, 
        {
            "location": "/configuration/#dc_filter_opt", 
            "text": "dc blocker options", 
            "title": "dc_filter_opt"
        }, 
        {
            "location": "/configuration/#quiet_demodulator_options", 
            "text": "typedef   struct   { \n\n     unsigned   int   shape ; \n\n     unsigned   int   samples_per_symbol ; \n\n     unsigned   int   symbol_delay ; \n\n     float   excess_bw ; \n\n     float   center_rads ;  }   quiet_demodulator_options ;   This set of options is used only by the decoder  The demodulator is a combination element which inverts the operations of the modulator. It first mixes down from the carrier and then performs decimation to recover the signal.", 
            "title": "quiet_demodulator_options"
        }, 
        {
            "location": "/configuration/#shape_1", 
            "text": "Numerical value for shape of decimation filter.  This uses the same set of values as  quiet_modulator_options.shape", 
            "title": "shape"
        }, 
        {
            "location": "/configuration/#samples_per_symbol_1", 
            "text": "decimation factor", 
            "title": "samples_per_symbol"
        }, 
        {
            "location": "/configuration/#symbol_delay_1", 
            "text": "decimation filter delay", 
            "title": "symbol_delay"
        }, 
        {
            "location": "/configuration/#excess_bw_1", 
            "text": "decimation roll-off factor", 
            "title": "excess_bw"
        }, 
        {
            "location": "/configuration/#center_rads_1", 
            "text": "carrier frequency, [0, 2*pi)", 
            "title": "center_rads"
        }, 
        {
            "location": "/configuration/#quiet_encoding_t", 
            "text": "typedef   enum   { \n\n     ofdm_encoding , \n\n     modem_encoding , \n\n     gmsk_encoding  }   quiet_encoding_t ;   Selects operational mode for encoder/decoder. OFDM and Modem mode use the same modulation schemes while gmsk ignores the supplied scheme and uses its own", 
            "title": "quiet_encoding_t"
        }, 
        {
            "location": "/configuration/#ofdm_encoding", 
            "text": "Encode/decode in OFDM mode.", 
            "title": "ofdm_encoding"
        }, 
        {
            "location": "/configuration/#modem_encoding", 
            "text": "Encode/decode in modem mode.", 
            "title": "modem_encoding"
        }, 
        {
            "location": "/configuration/#gmsk_encoding", 
            "text": "Encode/decode in gaussian minimum shift keying mode.  GMSK mode does not offer the modulation modes given by the other encodings. It has a fairly limited bitrate, but the advantage of GMSK is that its receiver does not need to compute any FFTs, making it suitable for low-power receivers or situations with little computational capacity.", 
            "title": "gmsk_encoding"
        }, 
        {
            "location": "/configuration/#quiet_ofdm_options", 
            "text": "typedef   struct   { \n\n     unsigned   int   num_subcarriers ; \n\n     unsigned   int   cyclic_prefix_len ; \n\n     unsigned   int   taper_len ; \n\n     size_t   left_band ; \n\n     size_t   right_band ;  }   quiet_ofdm_options ;   These options configure the behavior of OFDM, orthogonal frequency division multiplexing, as used by the encoder. OFDM places the modulated symbols on to multiple orthogonal subcarriers. This can help the decoder estabilish good equalization when used on a system with uneven filtering.", 
            "title": "quiet_ofdm_options"
        }, 
        {
            "location": "/configuration/#num_subcarriers", 
            "text": "total number of subcarriers used, inlcuding guard bands and pilots", 
            "title": "num_subcarriers"
        }, 
        {
            "location": "/configuration/#cyclic_prefix_len", 
            "text": "number of cyclic prefix samples between symbols", 
            "title": "cyclic_prefix_len"
        }, 
        {
            "location": "/configuration/#taper_len", 
            "text": "number of taper window between symbols", 
            "title": "taper_len"
        }, 
        {
            "location": "/configuration/#left_band", 
            "text": "number of extra guard subcarriers inserted on left (low freq)", 
            "title": "left_band"
        }, 
        {
            "location": "/configuration/#right_band", 
            "text": "number of extra guard subcarriers inserted on right (high freq)", 
            "title": "right_band"
        }, 
        {
            "location": "/configuration/#quiet_checksum_scheme_t", 
            "text": "typedef   enum   { \n\n     quiet_checksum_none   =   1 , \n\n     quiet_checksum_8bit , \n\n     quiet_checksum_crc8 , \n\n     quiet_checksum_crc16 , \n\n     quiet_checksum_crc24 , \n\n     quiet_checksum_crc32  }   quiet_checksum_scheme_t ;", 
            "title": "quiet_checksum_scheme_t"
        }, 
        {
            "location": "/configuration/#quiet_checksum_none", 
            "text": "no error-detection", 
            "title": "quiet_checksum_none"
        }, 
        {
            "location": "/configuration/#quiet_checksum_8bit", 
            "text": "8-bit checksum", 
            "title": "quiet_checksum_8bit"
        }, 
        {
            "location": "/configuration/#quiet_checksum_crc8", 
            "text": "8-bit CRC", 
            "title": "quiet_checksum_crc8"
        }, 
        {
            "location": "/configuration/#quiet_checksum_crc16", 
            "text": "16-bit CRC", 
            "title": "quiet_checksum_crc16"
        }, 
        {
            "location": "/configuration/#quiet_checksum_crc24", 
            "text": "24-bit CRC", 
            "title": "quiet_checksum_crc24"
        }, 
        {
            "location": "/configuration/#quiet_checksum_crc32", 
            "text": "32-bit CRC", 
            "title": "quiet_checksum_crc32"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_scheme_t", 
            "text": "typedef   enum   { \n\n     quiet_error_correction_none   =   1 , \n\n     quiet_error_correction_repeat_3 , \n\n     quiet_error_correction_repeat_5 , \n\n     quiet_error_correction_hamming_7_4 , \n\n     quiet_error_correction_hamming_7_4_parity , \n\n     quiet_error_correction_hamming_12_8 , \n\n     quiet_error_correction_golay_24_12 , \n\n     quiet_error_correction_secded_22_16 , \n\n     quiet_error_correction_secded_39_32 , \n\n     quiet_error_correction_secded_72_64 , \n\n     quiet_error_correction_conv_12_7 , \n\n     quiet_error_correction_conv_12_9 , \n\n     quiet_error_correction_conv_13_9 , \n\n     quiet_error_correction_conv_16_15 , \n\n     quiet_error_correction_conv_perf_23_7 , \n\n     quiet_error_correction_conv_perf_34_7 , \n\n     quiet_error_correction_conv_perf_45_7 , \n\n     quiet_error_correction_conv_perf_56_7 , \n\n     quiet_error_correction_conv_perf_67_7 , \n\n     quiet_error_correction_conv_perf_78_7 , \n\n     quiet_error_correction_conv_perf_23_9 , \n\n     quiet_error_correction_conv_perf_34_9 , \n\n     quiet_error_correction_conv_perf_45_9 , \n\n     quiet_error_correction_conv_perf_56_9 , \n\n     quiet_error_correction_conv_perf_67_9 , \n\n     quiet_error_correction_conv_perf_78_9 , \n\n     quiet_error_correction_reed_solomon_223_255  }   quiet_error_correction_scheme_t ;", 
            "title": "quiet_error_correction_scheme_t"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_none", 
            "text": "no error-correction", 
            "title": "quiet_error_correction_none"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_repeat_3", 
            "text": "simple repeat code, r1/3", 
            "title": "quiet_error_correction_repeat_3"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_repeat_5", 
            "text": "simple repeat code, r1/5", 
            "title": "quiet_error_correction_repeat_5"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_hamming_7_4", 
            "text": "Hamming (7,4) block code, r1/2 (really 4/7)", 
            "title": "quiet_error_correction_hamming_7_4"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_hamming_7_4_parity", 
            "text": "Hamming (7,4) with extra parity bit, r1/2.", 
            "title": "quiet_error_correction_hamming_7_4_parity"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_hamming_12_8", 
            "text": "Hamming (12,8) block code, r2/3.", 
            "title": "quiet_error_correction_hamming_12_8"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_golay_24_12", 
            "text": "Golay (24,12) block code, r1/2.", 
            "title": "quiet_error_correction_golay_24_12"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_secded_22_16", 
            "text": "SEC-DED (22,16) block code, r8/11.", 
            "title": "quiet_error_correction_secded_22_16"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_secded_39_32", 
            "text": "SEC-DED (39,32) block code.", 
            "title": "quiet_error_correction_secded_39_32"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_secded_72_64", 
            "text": "SEC-DED (72,64) block code, r8/9.", 
            "title": "quiet_error_correction_secded_72_64"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_12_7", 
            "text": "convolutional code r1/2, K=7, dfree=10", 
            "title": "quiet_error_correction_conv_12_7"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_12_9", 
            "text": "convolutional code r1/2, K=9, dfree=12", 
            "title": "quiet_error_correction_conv_12_9"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_13_9", 
            "text": "convolutional code r1/3, K=9, dfree=18", 
            "title": "quiet_error_correction_conv_13_9"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_16_15", 
            "text": "convolutional code 1/6, K=15, dfree =57 (Heller 1968)", 
            "title": "quiet_error_correction_conv_16_15"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_23_7", 
            "text": "perforated convolutional code r2/3, K=7, dfree=6", 
            "title": "quiet_error_correction_conv_perf_23_7"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_34_7", 
            "text": "perforated convolutional code r3/4, K=7, dfree=5", 
            "title": "quiet_error_correction_conv_perf_34_7"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_45_7", 
            "text": "perforated convolutional code r4/5, K=7, dfree=4", 
            "title": "quiet_error_correction_conv_perf_45_7"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_56_7", 
            "text": "perforated convolutional code r5/6, K=7, dfree=4", 
            "title": "quiet_error_correction_conv_perf_56_7"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_67_7", 
            "text": "perforated convolutional code r6/7, K=7, dfree=3", 
            "title": "quiet_error_correction_conv_perf_67_7"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_78_7", 
            "text": "perforated convolutional code r7/8, K=7, dfree=3", 
            "title": "quiet_error_correction_conv_perf_78_7"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_23_9", 
            "text": "perforated convolutional code r2/3, K=9, dfree=7", 
            "title": "quiet_error_correction_conv_perf_23_9"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_34_9", 
            "text": "perforated convolutional code r3/4, K=9, dfree=6", 
            "title": "quiet_error_correction_conv_perf_34_9"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_45_9", 
            "text": "perforated convolutional code r4/5, K=9, dfree=5", 
            "title": "quiet_error_correction_conv_perf_45_9"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_56_9", 
            "text": "perforated convolutional code r5/6, K=9, dfree=5", 
            "title": "quiet_error_correction_conv_perf_56_9"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_67_9", 
            "text": "perforated convolutional code r6/7, K=9, dfree=4", 
            "title": "quiet_error_correction_conv_perf_67_9"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_conv_perf_78_9", 
            "text": "perforated convolutional code r7/8, K=9, dfree=4", 
            "title": "quiet_error_correction_conv_perf_78_9"
        }, 
        {
            "location": "/configuration/#quiet_error_correction_reed_solomon_223_255", 
            "text": "Reed-Solomon m=8, n=255, k=223.", 
            "title": "quiet_error_correction_reed_solomon_223_255"
        }, 
        {
            "location": "/configuration/#quiet_modulation_scheme_t", 
            "text": "typedef   enum   { \n\n     quiet_modulation_psk2   =   1 , \n\n     quiet_modulation_psk4 , \n\n     quiet_modulation_psk8 , \n\n     quiet_modulation_psk16 , \n\n     quiet_modulation_psk32 , \n\n     quiet_modulation_psk64 , \n\n     quiet_modulation_psk128 , \n\n     quiet_modulation_psk256 , \n\n     quiet_modulation_dpsk2 , \n\n     quiet_modulation_dpsk4 , \n\n     quiet_modulation_dpsk8 , \n\n     quiet_modulation_dpsk16 , \n\n     quiet_modulation_dpsk32 , \n\n     quiet_modulation_dpsk64 , \n\n     quiet_modulation_dpsk128 , \n\n     quiet_modulation_dpsk256 , \n\n     quiet_modulation_ask2 , \n\n     quiet_modulation_ask4 , \n\n     quiet_modulation_ask8 , \n\n     quiet_modulation_ask16 , \n\n     quiet_modulation_ask32 , \n\n     quiet_modulation_ask64 , \n\n     quiet_modulation_ask128 , \n\n     quiet_modulation_ask256 , \n\n     quiet_modulation_qask4 , \n\n     quiet_modulation_qask8 , \n\n     quiet_modulation_qask16 , \n\n     quiet_modulation_qask32 , \n\n     quiet_modulation_qask64 , \n\n     quiet_modulation_qask128 , \n\n     quiet_modulation_qask256 , \n\n     quiet_modulation_qask512 , \n\n     quiet_modulation_qask1024 , \n\n     quiet_modulation_qask2048 , \n\n     quiet_modulation_qask4096 , \n\n     quiet_modulation_qask8192 , \n\n     quiet_modulation_qask16384 , \n\n     quiet_modulation_qask32768 , \n\n     quiet_modulation_qask65536 , \n\n     quiet_modulation_apsk4 , \n\n     quiet_modulation_apsk8 , \n\n     quiet_modulation_apsk16 , \n\n     quiet_modulation_apsk32 , \n\n     quiet_modulation_apsk64 , \n\n     quiet_modulation_apsk128 , \n\n     quiet_modulation_apsk256 , \n\n     quiet_modulation_bpsk , \n\n     quiet_modulation_qpsk , \n\n     quiet_modulation_ook , \n\n     quiet_modulation_sqask32 , \n\n     quiet_modulation_sqask128 , \n\n     quiet_modulation_v29 , \n\n     quiet_modulation_opt_qask16 , \n\n     quiet_modulation_opt_qask32 , \n\n     quiet_modulation_opt_qask64 , \n\n     quiet_modulation_opt_qask128 , \n\n     quiet_modulation_opt_qask256 , \n\n     quiet_modulation_vtech  }   quiet_modulation_scheme_t ;", 
            "title": "quiet_modulation_scheme_t"
        }, 
        {
            "location": "/configuration/#quiet_modulation_psk2", 
            "text": "phase-shift keying-2", 
            "title": "quiet_modulation_psk2"
        }, 
        {
            "location": "/configuration/#quiet_modulation_psk4", 
            "text": "phase-shift keying-4", 
            "title": "quiet_modulation_psk4"
        }, 
        {
            "location": "/configuration/#quiet_modulation_psk8", 
            "text": "phase-shift keying-8", 
            "title": "quiet_modulation_psk8"
        }, 
        {
            "location": "/configuration/#quiet_modulation_psk16", 
            "text": "phase-shift keying-16", 
            "title": "quiet_modulation_psk16"
        }, 
        {
            "location": "/configuration/#quiet_modulation_psk32", 
            "text": "phase-shift keying-32", 
            "title": "quiet_modulation_psk32"
        }, 
        {
            "location": "/configuration/#quiet_modulation_psk64", 
            "text": "phase-shift keying-64", 
            "title": "quiet_modulation_psk64"
        }, 
        {
            "location": "/configuration/#quiet_modulation_psk128", 
            "text": "phase-shift keying-128", 
            "title": "quiet_modulation_psk128"
        }, 
        {
            "location": "/configuration/#quiet_modulation_psk256", 
            "text": "phase-shift keying-256", 
            "title": "quiet_modulation_psk256"
        }, 
        {
            "location": "/configuration/#quiet_modulation_dpsk2", 
            "text": "differential phase-shift keying-2", 
            "title": "quiet_modulation_dpsk2"
        }, 
        {
            "location": "/configuration/#quiet_modulation_dpsk4", 
            "text": "differential phase-shift keying-4", 
            "title": "quiet_modulation_dpsk4"
        }, 
        {
            "location": "/configuration/#quiet_modulation_dpsk8", 
            "text": "differential phase-shift keying-8", 
            "title": "quiet_modulation_dpsk8"
        }, 
        {
            "location": "/configuration/#quiet_modulation_dpsk16", 
            "text": "differential phase-shift keying-16", 
            "title": "quiet_modulation_dpsk16"
        }, 
        {
            "location": "/configuration/#quiet_modulation_dpsk32", 
            "text": "differential phase-shift keying-32", 
            "title": "quiet_modulation_dpsk32"
        }, 
        {
            "location": "/configuration/#quiet_modulation_dpsk64", 
            "text": "differential phase-shift keying-64", 
            "title": "quiet_modulation_dpsk64"
        }, 
        {
            "location": "/configuration/#quiet_modulation_dpsk128", 
            "text": "differential phase-shift keying-128", 
            "title": "quiet_modulation_dpsk128"
        }, 
        {
            "location": "/configuration/#quiet_modulation_dpsk256", 
            "text": "differential phase-shift keying-256", 
            "title": "quiet_modulation_dpsk256"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ask2", 
            "text": "amplitude-shift keying-2", 
            "title": "quiet_modulation_ask2"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ask4", 
            "text": "amplitude-shift keying-4", 
            "title": "quiet_modulation_ask4"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ask8", 
            "text": "amplitude-shift keying-8", 
            "title": "quiet_modulation_ask8"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ask16", 
            "text": "amplitude-shift keying-16", 
            "title": "quiet_modulation_ask16"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ask32", 
            "text": "amplitude-shift keying-32", 
            "title": "quiet_modulation_ask32"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ask64", 
            "text": "amplitude-shift keying-64", 
            "title": "quiet_modulation_ask64"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ask128", 
            "text": "amplitude-shift keying-128", 
            "title": "quiet_modulation_ask128"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ask256", 
            "text": "amplitude-shift keying-256", 
            "title": "quiet_modulation_ask256"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask4", 
            "text": "quadrature amplitude-shift keying-4", 
            "title": "quiet_modulation_qask4"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask8", 
            "text": "quadrature amplitude-shift keying-8", 
            "title": "quiet_modulation_qask8"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask16", 
            "text": "quadrature amplitude-shift keying-16", 
            "title": "quiet_modulation_qask16"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask32", 
            "text": "quadrature amplitude-shift keying-32", 
            "title": "quiet_modulation_qask32"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask64", 
            "text": "quadrature amplitude-shift keying-64", 
            "title": "quiet_modulation_qask64"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask128", 
            "text": "quadrature amplitude-shift keying-128", 
            "title": "quiet_modulation_qask128"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask256", 
            "text": "quadrature amplitude-shift keying-256", 
            "title": "quiet_modulation_qask256"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask512", 
            "text": "quadrature amplitude-shift keying-512", 
            "title": "quiet_modulation_qask512"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask1024", 
            "text": "quadrature amplitude-shift keying-1024", 
            "title": "quiet_modulation_qask1024"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask2048", 
            "text": "quadrature amplitude-shift keying-2048", 
            "title": "quiet_modulation_qask2048"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask4096", 
            "text": "quadrature amplitude-shift keying-4096", 
            "title": "quiet_modulation_qask4096"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask8192", 
            "text": "quadrature amplitude-shift keying-8192", 
            "title": "quiet_modulation_qask8192"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask16384", 
            "text": "quadrature amplitude-shift keying-16384", 
            "title": "quiet_modulation_qask16384"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask32768", 
            "text": "quadrature amplitude-shift keying-32768", 
            "title": "quiet_modulation_qask32768"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qask65536", 
            "text": "quadrature amplitude-shift keying-65536", 
            "title": "quiet_modulation_qask65536"
        }, 
        {
            "location": "/configuration/#quiet_modulation_apsk4", 
            "text": "amplitude phase-shift keying-4", 
            "title": "quiet_modulation_apsk4"
        }, 
        {
            "location": "/configuration/#quiet_modulation_apsk8", 
            "text": "amplitude phase-shift keying-8", 
            "title": "quiet_modulation_apsk8"
        }, 
        {
            "location": "/configuration/#quiet_modulation_apsk16", 
            "text": "amplitude phase-shift keying-16", 
            "title": "quiet_modulation_apsk16"
        }, 
        {
            "location": "/configuration/#quiet_modulation_apsk32", 
            "text": "amplitude phase-shift keying-32", 
            "title": "quiet_modulation_apsk32"
        }, 
        {
            "location": "/configuration/#quiet_modulation_apsk64", 
            "text": "amplitude phase-shift keying-64", 
            "title": "quiet_modulation_apsk64"
        }, 
        {
            "location": "/configuration/#quiet_modulation_apsk128", 
            "text": "amplitude phase-shift keying-128", 
            "title": "quiet_modulation_apsk128"
        }, 
        {
            "location": "/configuration/#quiet_modulation_apsk256", 
            "text": "amplitude phase-shift keying-256", 
            "title": "quiet_modulation_apsk256"
        }, 
        {
            "location": "/configuration/#quiet_modulation_bpsk", 
            "text": "binary phase-shift keying", 
            "title": "quiet_modulation_bpsk"
        }, 
        {
            "location": "/configuration/#quiet_modulation_qpsk", 
            "text": "quaternary phase-shift keying", 
            "title": "quiet_modulation_qpsk"
        }, 
        {
            "location": "/configuration/#quiet_modulation_ook", 
            "text": "on-off keying", 
            "title": "quiet_modulation_ook"
        }, 
        {
            "location": "/configuration/#quiet_modulation_sqask32", 
            "text": "square quadrature amplitude-shift keying-32", 
            "title": "quiet_modulation_sqask32"
        }, 
        {
            "location": "/configuration/#quiet_modulation_sqask128", 
            "text": "square quadrature amplitude-shift keying-128", 
            "title": "quiet_modulation_sqask128"
        }, 
        {
            "location": "/configuration/#quiet_modulation_v29", 
            "text": "V.29 star constellation.", 
            "title": "quiet_modulation_v29"
        }, 
        {
            "location": "/configuration/#quiet_modulation_opt_qask16", 
            "text": "optimal quadrature amplitude-shift keying-16", 
            "title": "quiet_modulation_opt_qask16"
        }, 
        {
            "location": "/configuration/#quiet_modulation_opt_qask32", 
            "text": "optimal quadrature amplitude-shift keying-32", 
            "title": "quiet_modulation_opt_qask32"
        }, 
        {
            "location": "/configuration/#quiet_modulation_opt_qask64", 
            "text": "optimal quadrature amplitude-shift keying-64", 
            "title": "quiet_modulation_opt_qask64"
        }, 
        {
            "location": "/configuration/#quiet_modulation_opt_qask128", 
            "text": "optimal quadrature amplitude-shift keying-128", 
            "title": "quiet_modulation_opt_qask128"
        }, 
        {
            "location": "/configuration/#quiet_modulation_opt_qask256", 
            "text": "optimal quadrature amplitude-shift keying-256", 
            "title": "quiet_modulation_opt_qask256"
        }, 
        {
            "location": "/configuration/#quiet_modulation_vtech", 
            "text": "Virginia Tech logo constellation.", 
            "title": "quiet_modulation_vtech"
        }, 
        {
            "location": "/configuration/#quiet_dc_filter_options", 
            "text": "typedef   struct   { \n\n     float   alpha ;  }   quiet_dc_filter_options ;   This DC blocker is applied near the end of the signal chain so that any leftover DC component is removed. This is important for audio signals as we do not want to send any DC out to speakers  transfer function H(z)=(1 - (z^-1))/(1 - (1-alpha)*(z^-1))", 
            "title": "quiet_dc_filter_options"
        }, 
        {
            "location": "/configuration/#alpha", 
            "text": "", 
            "title": "alpha"
        }, 
        {
            "location": "/configuration/#quiet_resampler_options", 
            "text": "typedef   struct   { \n\n     size_t   delay ; \n\n     float   bandwidth ; \n\n     float   attenuation ; \n\n     size_t   filter_bank_size ;  }   quiet_resampler_options ;   Controls arbitrary resample unit used by libquiet after generating 44.1kHz signal or before decoding signal  This resampler will be applied to set the sample rate to the rate given when creating an encoder or decoder", 
            "title": "quiet_resampler_options"
        }, 
        {
            "location": "/configuration/#delay", 
            "text": "", 
            "title": "delay"
        }, 
        {
            "location": "/configuration/#bandwidth", 
            "text": "", 
            "title": "bandwidth"
        }, 
        {
            "location": "/configuration/#attenuation", 
            "text": "", 
            "title": "attenuation"
        }, 
        {
            "location": "/configuration/#filter_bank_size", 
            "text": "", 
            "title": "filter_bank_size"
        }, 
        {
            "location": "/encoding/", 
            "text": "Encoding Raw Samples\n\n\nquiet_sample_t\n\n\ntypedef\n \nfloat\n \nquiet_sample_t\n;\n\n\n\n\n\n\nAll modem values generated are floating-point values between -1.0 and 1.0.\n\n\nquiet_encoder\n\n\nstruct\n \nquiet_encoder\n;\n\n\n\ntypedef\n \nstruct\n \nquiet_encoder\n \nquiet_encoder\n;\n\n\n\n\n\n\nquiet_encoder_create\n\n\nquiet_encoder\n \n*\n\n\n\nquiet_encoder_create\n(\nconst\n \nquiet_encoder_options\n \n*\nopt\n,\n\n\n                     \nfloat\n \nsample_rate\n);\n\n\n\n\n\n\nquiet_encoder_create creates and initializes a new libquiet encoder for a given set of options and sample rate. As libquiet makes use of its own resampler, it is suggested to use the default sample rate of your device, so as to not invoke any implicit resamplers.\n\n\nParameters\n\n\nopt\n - \nquiet_encoder_options\n containing encoder configuration\n\n\nsample_rate\n - Sample rate that encoder will generate at\n\n\nReturns\n\n\npointer to a new encoder object, or NULL if creation failed\n\n\nquiet_encoder_send\n\n\nssize_t\n\n\n\nquiet_encoder_send\n(\nquiet_encoder\n \n*\ne\n,\n\n\n                   \nconst\n \nvoid\n \n*\nbuf\n,\n\n\n                   \nsize_t\n \nlen\n);\n\n\n\n\n\n\nquiet_encoder_send copies the frame provided by the user to an internal transmit queue. By default, this is a nonblocking call and will fail if the queue is full. However, if quiet_encoder_set_blocking has been called first, then it will wait for as much as the timeout length specified there if the frame cannot be immediately written.\n\n\nThe frame provided must be no longer than the maximum frame length of the encoder. If the frame is longer, it will be rejected entirely, and no data will be transmitted.\n\n\nIf libquiet was built and linked with pthread, then this function may be called from any thread, and by multiple threads concurrently.\n\n\nquiet_encoder_send will return 0 if the queue is closed to signal EOF.\n\n\nquiet_encoder_send will return a negative value and set the last error to quiet_timedout if the send queue is full and no space was made before the timeout\n\n\nquiet_encoder_send will return a negative value and set the last error to quiet_would_block if the send queue is full and the encoder is in nonblocking mode\n\n\nParameters\n\n\ne\n - encoder object\n\n\nbuf\n - user buffer containing the frame payload\n\n\nlen\n - the number of bytes in buf\n\n\nReturns\n\n\nthe number of bytes copied from the buffer, 0 if the queue is closed, or -1 if sending failed\n\n\nquiet_encoder_set_blocking\n\n\nvoid\n\n\n\nquiet_encoder_set_blocking\n(\nquiet_encoder\n \n*\ne\n,\n\n\n                           \ntime_t\n \nsec\n,\n\n\n                           \nlong\n \nnano\n);\n\n\n\n\n\n\nquiet_encoder_set_blocking changes the behavior of quiet_encoder_send so that it will block until a frame can be written. It will block for approximately (nano + 1000000000*sec) nanoseconds.\n\n\nIf \nsec\n and \nnano\n are both 0, then quiet_encoder_send will block indefinitely until a frame is sent.\n\n\nThis function is only supported on systems with pthread. Calling quiet_encoder_set_blocking on a host without pthread will assert false.\n\n\nParameters\n\n\ne\n - encoder object\n\n\nsec\n - time_t number of seconds to block for\n\n\nnano\n - long number of nanoseconds to block for\n\n\nquiet_encoder_set_nonblocking\n\n\nvoid\n\n\n\nquiet_encoder_set_nonblocking\n(\nquiet_encoder\n \n*\ne\n);\n\n\n\n\n\n\nquiet_encoder_set_nonblocking changes the behavior of quiet_encoder_send so that it will not block if it cannot write a frame. This function restores the default behavior after quiet_encoder_set_blocking has been called.\n\n\nParameters\n\n\ne\n - encoder object\n\n\nquiet_encoder_set_emit_blocking\n\n\nvoid\n\n\n\nquiet_encoder_set_emit_blocking\n(\nquiet_encoder\n \n*\ne\n,\n\n\n                                \ntime_t\n \nsec\n,\n\n\n                                \nlong\n \nnano\n);\n\n\n\n\n\n\nquiet_encoder_set_emit_blocking changes quiet_encoder_emit so that it will block until a frame is read. It will block for approximately (nano + 1000000000*sec) nanoseconds.\n\n\nquiet_encoder_emit may emit some empty (silence) samples if one frame is available but more frames are needed for the full length of the block given to quiet_encoder_emit. That is, quiet_encoder_emit will not block the tail of one frame while waiting for the next.\n\n\nIf \nsec\n and \nnano\n are both 0, then quiet_encoder_emit will block indefinitely until a frame is read.\n\n\nThis function is only supported on systems with pthread. Calling quiet_encoder_set_blocking on a host without pthread will assert false.\n\n\nParameters\n\n\ne\n - encoder object\n\n\nsec\n - time_t number of seconds to block for\n\n\nnano\n - long number of nanoseconds to block for\n\n\nquiet_encoder_set_emit_nonblocking\n\n\nvoid\n\n\n\nquiet_encoder_set_emit_nonblocking\n(\nquiet_encoder\n \n*\ne\n);\n\n\n\n\n\n\nquiet_encoder_set_emit_nonblocking changes the behavior of quiet_encoder_emit so that it will not block if it cannot read a frame. This function restores the default behavior after quiet_encoder_set_emit_blocking has been called.\n\n\nParameters\n\n\ne\n - encoder object\n\n\nquiet_encoder_clamp_frame_len\n\n\nsize_t\n\n\n\nquiet_encoder_clamp_frame_len\n(\nquiet_encoder\n \n*\ne\n,\n\n\n                              \nsize_t\n \nsample_len\n);\n\n\n\n\n\n\nquiet_encoder_clamp_frame_len enables a mode in the encoder which prevents data frames from overlapping multiple blocks of samples, e.g. multiple calls to quiet_encoder_emit. This can be very convenient if your environment cannot keep up in realtime due to e.g. GC pauses. The transmission of data will succeed as long as the blocks of samples are played out smoothly (gaps between blocks are ok, gaps within blocks are not ok).\n\n\nCalling this with the size of your sample block will clamp the frame length of this encoder and toggle the \nis_close_frame\n flag which will ensure that sample blocks will always end in silence. This will never result in a frame length longer than the one provided in the creation of the encoder, but it may result in a shorter frame length.\n\n\nParameters\n\n\ne\n - encoder object\n\n\nsample_len\n - size of sample block\n\n\nReturns\n\n\nthe new frame length\n\n\nquiet_encoder_get_frame_len\n\n\nsize_t\n\n\n\nquiet_encoder_get_frame_len\n(\nconst\n \nquiet_encoder\n \n*\ne\n);\n\n\n\n\n\n\nParameters\n\n\ne\n - encoder object\n\n\nReturns\n\n\nencoder's maximum frame length, e.g. the largest length that can be passed to quiet_encoder_send\n\n\nquiet_encoder_emit\n\n\nssize_t\n\n\n\nquiet_encoder_emit\n(\nquiet_encoder\n \n*\ne\n,\n\n\n                   \nquiet_sample_t\n \n*\nsamplebuf\n,\n\n\n                   \nsize_t\n \nsamplebuf_len\n);\n\n\n\n\n\n\nquiet_encoder_emit fills a block of samples pointed to by samplebuf by reading frames from its transmit queue and encoding them into sound by using the configuration specified at creation. These samples can be written out directly to a file or soundcard.\n\n\nIf you are using a soundcard, you will have to carefully choose the sample size block. Typically, the largest size is 16384 samples. Larger block sizes will help hide uneven latencies in the encoding process and ensure smoother transmission at the cost of longer latencies.\n\n\nquiet_encoder_emit may return fewer than the number of samples requested. Unlike quiet_encoder_send, quiet_encoder_emit does not block, even when blocking mode is enabled. This is because soundcard interfaces typically require realtime sample generation.\n\n\nIf quiet_encoder_emit returns 0, then the transmit queue is closed and empty, and no future calls to quiet_encoder_emit will retrieve any more samples.\n\n\nParameters\n\n\ne\n - encoder object\n\n\nsamplebuf\n - user-provided array where samples will be written\n\n\nsamplebuf_len\n - length of user-provided array\n\n\nReturns\n\n\nthe number of samples written to samplebuf, which shall never exceed samplebuf_len. If the returned number of samples written is less than samplebuf_len, then the encoder has finished encoding the payload (its transmit queue is empty and all state has been flushed out). The user should 0-fill any remaining length if the block is to be transmitted.\n\n\nIf quiet_encoder_emit returns a negative length, then it will set the quiet error. Most commonly, this will happen when the transmit queue is empty and there are no frames ready to send, but the queue is still open. If and only if the queue is closed and has been completely read, quiet_encoder_emit will return 0 to signal EOF.\n\n\nErrors\n\n\nfoo\n - bar baz\n\n\nqux\n - quuux\n\n\nquiet_encoder_close\n\n\nvoid\n\n\n\nquiet_encoder_close\n(\nquiet_encoder\n \n*\ne\n);\n\n\n\n\n\n\nquiet_encoder_close closes the encoder object. This has the effect of rejecting any future calls to quiet_encoder_send. Any previously queued frames will be written by quiet_encoder_emit. Once the send queue is empty, quiet_encoder_emit will set last error to quiet_closed.\n\n\nParameters\n\n\ne\n - encoder object\n\n\nquiet_encoder_destroy\n\n\nvoid\n\n\n\nquiet_encoder_destroy\n(\nquiet_encoder\n \n*\ne\n);\n\n\n\n\n\n\nquiet_encoder_destroy releases all resources allocated by the \nquiet_encoder\n. After calling this function, the user should not call any other encoder functions on the \nquiet_encoder\n.\n\n\nParameters\n\n\ne\n - encoder object", 
            "title": "Encoding Raw Samples"
        }, 
        {
            "location": "/encoding/#encoding-raw-samples", 
            "text": "", 
            "title": "Encoding Raw Samples"
        }, 
        {
            "location": "/encoding/#quiet_sample_t", 
            "text": "typedef   float   quiet_sample_t ;   All modem values generated are floating-point values between -1.0 and 1.0.", 
            "title": "quiet_sample_t"
        }, 
        {
            "location": "/encoding/#quiet_encoder", 
            "text": "struct   quiet_encoder ;  typedef   struct   quiet_encoder   quiet_encoder ;", 
            "title": "quiet_encoder"
        }, 
        {
            "location": "/encoding/#quiet_encoder_create", 
            "text": "quiet_encoder   *  quiet_encoder_create ( const   quiet_encoder_options   * opt , \n\n                      float   sample_rate );   quiet_encoder_create creates and initializes a new libquiet encoder for a given set of options and sample rate. As libquiet makes use of its own resampler, it is suggested to use the default sample rate of your device, so as to not invoke any implicit resamplers.", 
            "title": "quiet_encoder_create"
        }, 
        {
            "location": "/encoding/#parameters", 
            "text": "opt  -  quiet_encoder_options  containing encoder configuration  sample_rate  - Sample rate that encoder will generate at", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#returns", 
            "text": "pointer to a new encoder object, or NULL if creation failed", 
            "title": "Returns"
        }, 
        {
            "location": "/encoding/#quiet_encoder_send", 
            "text": "ssize_t  quiet_encoder_send ( quiet_encoder   * e , \n\n                    const   void   * buf , \n\n                    size_t   len );   quiet_encoder_send copies the frame provided by the user to an internal transmit queue. By default, this is a nonblocking call and will fail if the queue is full. However, if quiet_encoder_set_blocking has been called first, then it will wait for as much as the timeout length specified there if the frame cannot be immediately written.  The frame provided must be no longer than the maximum frame length of the encoder. If the frame is longer, it will be rejected entirely, and no data will be transmitted.  If libquiet was built and linked with pthread, then this function may be called from any thread, and by multiple threads concurrently.  quiet_encoder_send will return 0 if the queue is closed to signal EOF.  quiet_encoder_send will return a negative value and set the last error to quiet_timedout if the send queue is full and no space was made before the timeout  quiet_encoder_send will return a negative value and set the last error to quiet_would_block if the send queue is full and the encoder is in nonblocking mode", 
            "title": "quiet_encoder_send"
        }, 
        {
            "location": "/encoding/#parameters_1", 
            "text": "e  - encoder object  buf  - user buffer containing the frame payload  len  - the number of bytes in buf", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#returns_1", 
            "text": "the number of bytes copied from the buffer, 0 if the queue is closed, or -1 if sending failed", 
            "title": "Returns"
        }, 
        {
            "location": "/encoding/#quiet_encoder_set_blocking", 
            "text": "void  quiet_encoder_set_blocking ( quiet_encoder   * e , \n\n                            time_t   sec , \n\n                            long   nano );   quiet_encoder_set_blocking changes the behavior of quiet_encoder_send so that it will block until a frame can be written. It will block for approximately (nano + 1000000000*sec) nanoseconds.  If  sec  and  nano  are both 0, then quiet_encoder_send will block indefinitely until a frame is sent.  This function is only supported on systems with pthread. Calling quiet_encoder_set_blocking on a host without pthread will assert false.", 
            "title": "quiet_encoder_set_blocking"
        }, 
        {
            "location": "/encoding/#parameters_2", 
            "text": "e  - encoder object  sec  - time_t number of seconds to block for  nano  - long number of nanoseconds to block for", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#quiet_encoder_set_nonblocking", 
            "text": "void  quiet_encoder_set_nonblocking ( quiet_encoder   * e );   quiet_encoder_set_nonblocking changes the behavior of quiet_encoder_send so that it will not block if it cannot write a frame. This function restores the default behavior after quiet_encoder_set_blocking has been called.", 
            "title": "quiet_encoder_set_nonblocking"
        }, 
        {
            "location": "/encoding/#parameters_3", 
            "text": "e  - encoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#quiet_encoder_set_emit_blocking", 
            "text": "void  quiet_encoder_set_emit_blocking ( quiet_encoder   * e , \n\n                                 time_t   sec , \n\n                                 long   nano );   quiet_encoder_set_emit_blocking changes quiet_encoder_emit so that it will block until a frame is read. It will block for approximately (nano + 1000000000*sec) nanoseconds.  quiet_encoder_emit may emit some empty (silence) samples if one frame is available but more frames are needed for the full length of the block given to quiet_encoder_emit. That is, quiet_encoder_emit will not block the tail of one frame while waiting for the next.  If  sec  and  nano  are both 0, then quiet_encoder_emit will block indefinitely until a frame is read.  This function is only supported on systems with pthread. Calling quiet_encoder_set_blocking on a host without pthread will assert false.", 
            "title": "quiet_encoder_set_emit_blocking"
        }, 
        {
            "location": "/encoding/#parameters_4", 
            "text": "e  - encoder object  sec  - time_t number of seconds to block for  nano  - long number of nanoseconds to block for", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#quiet_encoder_set_emit_nonblocking", 
            "text": "void  quiet_encoder_set_emit_nonblocking ( quiet_encoder   * e );   quiet_encoder_set_emit_nonblocking changes the behavior of quiet_encoder_emit so that it will not block if it cannot read a frame. This function restores the default behavior after quiet_encoder_set_emit_blocking has been called.", 
            "title": "quiet_encoder_set_emit_nonblocking"
        }, 
        {
            "location": "/encoding/#parameters_5", 
            "text": "e  - encoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#quiet_encoder_clamp_frame_len", 
            "text": "size_t  quiet_encoder_clamp_frame_len ( quiet_encoder   * e , \n\n                               size_t   sample_len );   quiet_encoder_clamp_frame_len enables a mode in the encoder which prevents data frames from overlapping multiple blocks of samples, e.g. multiple calls to quiet_encoder_emit. This can be very convenient if your environment cannot keep up in realtime due to e.g. GC pauses. The transmission of data will succeed as long as the blocks of samples are played out smoothly (gaps between blocks are ok, gaps within blocks are not ok).  Calling this with the size of your sample block will clamp the frame length of this encoder and toggle the  is_close_frame  flag which will ensure that sample blocks will always end in silence. This will never result in a frame length longer than the one provided in the creation of the encoder, but it may result in a shorter frame length.", 
            "title": "quiet_encoder_clamp_frame_len"
        }, 
        {
            "location": "/encoding/#parameters_6", 
            "text": "e  - encoder object  sample_len  - size of sample block", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#returns_2", 
            "text": "the new frame length", 
            "title": "Returns"
        }, 
        {
            "location": "/encoding/#quiet_encoder_get_frame_len", 
            "text": "size_t  quiet_encoder_get_frame_len ( const   quiet_encoder   * e );", 
            "title": "quiet_encoder_get_frame_len"
        }, 
        {
            "location": "/encoding/#parameters_7", 
            "text": "e  - encoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#returns_3", 
            "text": "encoder's maximum frame length, e.g. the largest length that can be passed to quiet_encoder_send", 
            "title": "Returns"
        }, 
        {
            "location": "/encoding/#quiet_encoder_emit", 
            "text": "ssize_t  quiet_encoder_emit ( quiet_encoder   * e , \n\n                    quiet_sample_t   * samplebuf , \n\n                    size_t   samplebuf_len );   quiet_encoder_emit fills a block of samples pointed to by samplebuf by reading frames from its transmit queue and encoding them into sound by using the configuration specified at creation. These samples can be written out directly to a file or soundcard.  If you are using a soundcard, you will have to carefully choose the sample size block. Typically, the largest size is 16384 samples. Larger block sizes will help hide uneven latencies in the encoding process and ensure smoother transmission at the cost of longer latencies.  quiet_encoder_emit may return fewer than the number of samples requested. Unlike quiet_encoder_send, quiet_encoder_emit does not block, even when blocking mode is enabled. This is because soundcard interfaces typically require realtime sample generation.  If quiet_encoder_emit returns 0, then the transmit queue is closed and empty, and no future calls to quiet_encoder_emit will retrieve any more samples.", 
            "title": "quiet_encoder_emit"
        }, 
        {
            "location": "/encoding/#parameters_8", 
            "text": "e  - encoder object  samplebuf  - user-provided array where samples will be written  samplebuf_len  - length of user-provided array", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#returns_4", 
            "text": "the number of samples written to samplebuf, which shall never exceed samplebuf_len. If the returned number of samples written is less than samplebuf_len, then the encoder has finished encoding the payload (its transmit queue is empty and all state has been flushed out). The user should 0-fill any remaining length if the block is to be transmitted.  If quiet_encoder_emit returns a negative length, then it will set the quiet error. Most commonly, this will happen when the transmit queue is empty and there are no frames ready to send, but the queue is still open. If and only if the queue is closed and has been completely read, quiet_encoder_emit will return 0 to signal EOF.", 
            "title": "Returns"
        }, 
        {
            "location": "/encoding/#errors", 
            "text": "foo  - bar baz  qux  - quuux", 
            "title": "Errors&dagger;"
        }, 
        {
            "location": "/encoding/#quiet_encoder_close", 
            "text": "void  quiet_encoder_close ( quiet_encoder   * e );   quiet_encoder_close closes the encoder object. This has the effect of rejecting any future calls to quiet_encoder_send. Any previously queued frames will be written by quiet_encoder_emit. Once the send queue is empty, quiet_encoder_emit will set last error to quiet_closed.", 
            "title": "quiet_encoder_close"
        }, 
        {
            "location": "/encoding/#parameters_9", 
            "text": "e  - encoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/encoding/#quiet_encoder_destroy", 
            "text": "void  quiet_encoder_destroy ( quiet_encoder   * e );   quiet_encoder_destroy releases all resources allocated by the  quiet_encoder . After calling this function, the user should not call any other encoder functions on the  quiet_encoder .", 
            "title": "quiet_encoder_destroy"
        }, 
        {
            "location": "/encoding/#parameters_10", 
            "text": "e  - encoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/", 
            "text": "Decoding Raw Samples\n\n\nquiet_decoder\n\n\nstruct\n \nquiet_decoder\n;\n\n\n\ntypedef\n \nstruct\n \nquiet_decoder\n \nquiet_decoder\n;\n\n\n\n\n\n\nquiet_decoder_create\n\n\nquiet_decoder\n \n*\n\n\n\nquiet_decoder_create\n(\nconst\n \nquiet_decoder_options\n \n*\nopt\n,\n\n\n                     \nfloat\n \nsample_rate\n);\n\n\n\n\n\n\nquiet_decoder_create creates and initializes a new libquiet decoder for a given set of options and sample rate.\n\n\nIt is recommended to use the default sample rate of your device in order to avoid any possible implicit resampling, which can distort samples.\n\n\nParameters\n\n\nopt\n - \nquiet_decoder_options\n containing decoder configuration\n\n\nsample_rate\n - Sample rate that decoder will consume at\n\n\nReturns\n\n\npointer to new decoder object, or NULL if creation failed.\n\n\nquiet_decoder_recv\n\n\nssize_t\n\n\n\nquiet_decoder_recv\n(\nquiet_decoder\n \n*\nd\n,\n\n\n                   \nuint8_t\n \n*\ndata\n,\n\n\n                   \nsize_t\n \nlen\n);\n\n\n\n\n\n\nquiet_decoder_recv reads one frame from the decoder's receive buffer. By default, this is a nonblocking call and will fail quickly if no frames are ready to be received. However, if quiet_decoder_set_blocking is called prior to this call, then it will wait for as much as the timeout specified there until it can read a frame.\n\n\nIf the user's supplied buffer is smaller than the length of the received frame, then only \nlen\n bytes will be copied to \ndata\n. The remaining bytes will be discarded.\n\n\nThis function will never return frames for which the checksum has failed.\n\n\nIf libquiet was built and linked with pthread, then this function may be called from any thread, and by multiple threads concurrently.\n\n\nquiet_decoder_recv will return 0 if the decoder has been closed and the receive queue is empty.\n\n\nquiet_decoder_recv will return a negative value and set the last error to quiet_timedout if blocking mode is enabled and no frame could be read before the timeout.\n\n\nquiet_decoder_recv will return a negative value and set the last error to quiet_would_block if nonblocking mode is enabled and no frame was available.\n\n\nParameters\n\n\nd\n - decoder object\n\n\ndata\n - user buffer which quiet will write received frame into\n\n\nlen\n - length of user-supplied buffer\n\n\nReturns\n\n\nnumber of bytes written to buffer, 0 at EOF, or -1 if no frames available\n\n\nquiet_decoder_set_blocking\n\n\nvoid\n\n\n\nquiet_decoder_set_blocking\n(\nquiet_decoder\n \n*\nd\n,\n\n\n                           \ntime_t\n \nsec\n,\n\n\n                           \nlong\n \nnano\n);\n\n\n\n\n\n\nquiet_decoder_set_blocking changes the behavior of quiet_decoder_recv so that it will block until a frame can be read. It will block for approximately (nano + 1000000000*sec) nanoseconds.\n\n\nIf \nsec\n and \nnano\n are both 0, then quiet_decoder_recv will block indefinitely until a frame is received.\n\n\nThis function is only supported on systems with pthread. Calling quiet_decoder_set_blocking on a host without pthread will assert false.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nsec\n - time_t number of seconds to block for\n\n\nnano\n - long number of nanoseconds to block for\n\n\nquiet_decoder_set_nonblocking\n\n\nvoid\n\n\n\nquiet_decoder_set_nonblocking\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_set_nonblocking changes the behavior of quiet_decoder_recv so that it will not block if it cannot read a frame. This function restores the default behavior after quiet_decoder_set_blocking has been called.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nquiet_decoder_consume\n\n\nvoid\n\n\n\nquiet_decoder_consume\n(\nquiet_decoder\n \n*\nd\n,\n\n\n                      \nconst\n \nquiet_sample_t\n \n*\nsamplebuf\n,\n\n\n                      \nsize_t\n \nsample_len\n);\n\n\n\n\n\n\nquiet_decoder_consume consumes sound samples and decodes them to frames. These can be samples obtained directly from a sound file, a soundcard's microphone, or any other source which can receive quiet_sample_t (float).\n\n\nIf you are using a soundcard, it is recommended to use the largest block size offered. Typically, this is 16384 samples. Larger block sizes will help hide uneven latencies in the decoding process and ensure smoother reception at the cost of longer latencies.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nsamplebuf\n - array of samples received from sound card\n\n\nsample_len\n - number of samples in samplebuf\n\n\nquiet_decoder_frame_in_progress\n\n\nbool\n\n\n\nquiet_decoder_frame_in_progress\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_frame_in_progress determines if a frame is likely in the process of being received. It inspects information in the decoding process and will be relevant to the last call to quiet_decoder_consume. There is no guarantee of accuracy from this function, and both false-negatives and false-positives can occur.\n\n\nThe output of this function can be useful to avoid collisions when two pairs of encoders/decoders share the same channel, e.g. in half-duplex.\n\n\nThis function must be called from the same thread which calls quiet_decoder_consume.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nReturns\n\n\ntrue if a frame is likely being received\n\n\nquiet_decoder_flush\n\n\nvoid\n\n\n\nquiet_decoder_flush\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_flush empties out all internal buffers and attempts to decode them\n\n\nThis function need only be called after the sound stream has stopped. It is especially useful for reading from sound files where there are no trailing samples to \"push\" the decoded data through the decoder's filters\n\n\nParameters\n\n\nd\n - decoder object\n\n\nquiet_decoder_close\n\n\nvoid\n\n\n\nquiet_decoder_close\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_close closes the decoder object. Future calls to quiet_decoder_consume will still attempt the decoding process but will not enqueue any decoded frames into the receive queue, e.g. they become cpu-expensive no-ops. Any previously enqueued frames can still be read out by quiet_decoder_recv, and once the receive queue is empty, quiet_decoder_recv will set the last error to quiet_closed.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nquiet_decoder_checksum_fails\n\n\nunsigned\n \nint\n\n\n\nquiet_decoder_checksum_fails\n(\nconst\n \nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_checksum_fails returns the total number of frames decoded but which failed checksum across the lifetime of the decoder.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nReturns\n\n\nTotal number of frames received with failed checksums\n\n\nquiet_decoder_consume_stats\n\n\nconst\n \nquiet_decoder_frame_stats\n \n*\n\n\n\nquiet_decoder_consume_stats\n(\nquiet_decoder\n \n*\nd\n,\n\n\n                            \nsize_t\n \n*\nnum_frames\n);\n\n\n\n\n\n\nquiet_decoder_consume_stats returns detailed info about the decoding process from the last call to quiet_decoder_consume_stats. It will save information on up to 8 frames. This includes frames which failed checksum. If quiet_decoder_consume found more than 8 frames, then information on only the first 8 frames will be saved.\n\n\nIn order to use this functionality, quiet_decoder_enable_stats must be called on the decoder object before calling quiet_decoder_consume.\n\n\nThis function must be called from the same thread that calls quiet_decoder_consume.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nnum_frames\n - number of frames at returned pointer\n\n\nReturns\n\n\nquiet_decoder_frame_stats\n which is an array of structs containing stats info, num_frames long\n\n\nquiet_decoder_recv_stats\n\n\nconst\n \nquiet_decoder_frame_stats\n \n*\n\n\n\nquiet_decoder_recv_stats\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_enable_stats\n\n\nvoid\n\n\n\nquiet_decoder_enable_stats\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_enable_stats allocates the required memory needed to save symbol and other information on each frame decode. Italso adds a small overhead needed to copy this information into an internal buffer.\n\n\nBy default, stats collection is disabled. Therefore, if the user would like to use quiet_decoder_consume_stats, then they must first call quiet_decoder_enable_stats.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nquiet_decoder_disable_stats\n\n\nvoid\n\n\n\nquiet_decoder_disable_stats\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_disable_stats frees all memory associated with stats collection.\n\n\nParameters\n\n\nd\n - decoder object\n\n\nquiet_decoder_set_stats_blocking\n\n\nvoid\n\n\n\nquiet_decoder_set_stats_blocking\n(\nquiet_decoder\n \n*\nd\n,\n\n\n                                 \ntime_t\n \nsec\n,\n\n\n                                 \nlong\n \nnano\n);\n\n\n\n\n\n\nquiet_decoder_set_stats_nonblocking\n\n\nvoid\n\n\n\nquiet_decoder_set_stats_nonblocking\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_destroy\n\n\nvoid\n\n\n\nquiet_decoder_destroy\n(\nquiet_decoder\n \n*\nd\n);\n\n\n\n\n\n\nquiet_decoder_destroy releases all resources allocated by the \nquiet_decoder\n. After calling this function, the user should not call any other decoder functions on the decoder.\n\n\nParameters\n\n\nd\n - decoder object", 
            "title": "Decoding Raw Samples"
        }, 
        {
            "location": "/decoding/#decoding-raw-samples", 
            "text": "", 
            "title": "Decoding Raw Samples"
        }, 
        {
            "location": "/decoding/#quiet_decoder", 
            "text": "struct   quiet_decoder ;  typedef   struct   quiet_decoder   quiet_decoder ;", 
            "title": "quiet_decoder"
        }, 
        {
            "location": "/decoding/#quiet_decoder_create", 
            "text": "quiet_decoder   *  quiet_decoder_create ( const   quiet_decoder_options   * opt , \n\n                      float   sample_rate );   quiet_decoder_create creates and initializes a new libquiet decoder for a given set of options and sample rate.  It is recommended to use the default sample rate of your device in order to avoid any possible implicit resampling, which can distort samples.", 
            "title": "quiet_decoder_create"
        }, 
        {
            "location": "/decoding/#parameters", 
            "text": "opt  -  quiet_decoder_options  containing decoder configuration  sample_rate  - Sample rate that decoder will consume at", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#returns", 
            "text": "pointer to new decoder object, or NULL if creation failed.", 
            "title": "Returns"
        }, 
        {
            "location": "/decoding/#quiet_decoder_recv", 
            "text": "ssize_t  quiet_decoder_recv ( quiet_decoder   * d , \n\n                    uint8_t   * data , \n\n                    size_t   len );   quiet_decoder_recv reads one frame from the decoder's receive buffer. By default, this is a nonblocking call and will fail quickly if no frames are ready to be received. However, if quiet_decoder_set_blocking is called prior to this call, then it will wait for as much as the timeout specified there until it can read a frame.  If the user's supplied buffer is smaller than the length of the received frame, then only  len  bytes will be copied to  data . The remaining bytes will be discarded.  This function will never return frames for which the checksum has failed.  If libquiet was built and linked with pthread, then this function may be called from any thread, and by multiple threads concurrently.  quiet_decoder_recv will return 0 if the decoder has been closed and the receive queue is empty.  quiet_decoder_recv will return a negative value and set the last error to quiet_timedout if blocking mode is enabled and no frame could be read before the timeout.  quiet_decoder_recv will return a negative value and set the last error to quiet_would_block if nonblocking mode is enabled and no frame was available.", 
            "title": "quiet_decoder_recv"
        }, 
        {
            "location": "/decoding/#parameters_1", 
            "text": "d  - decoder object  data  - user buffer which quiet will write received frame into  len  - length of user-supplied buffer", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#returns_1", 
            "text": "number of bytes written to buffer, 0 at EOF, or -1 if no frames available", 
            "title": "Returns"
        }, 
        {
            "location": "/decoding/#quiet_decoder_set_blocking", 
            "text": "void  quiet_decoder_set_blocking ( quiet_decoder   * d , \n\n                            time_t   sec , \n\n                            long   nano );   quiet_decoder_set_blocking changes the behavior of quiet_decoder_recv so that it will block until a frame can be read. It will block for approximately (nano + 1000000000*sec) nanoseconds.  If  sec  and  nano  are both 0, then quiet_decoder_recv will block indefinitely until a frame is received.  This function is only supported on systems with pthread. Calling quiet_decoder_set_blocking on a host without pthread will assert false.", 
            "title": "quiet_decoder_set_blocking"
        }, 
        {
            "location": "/decoding/#parameters_2", 
            "text": "d  - decoder object  sec  - time_t number of seconds to block for  nano  - long number of nanoseconds to block for", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#quiet_decoder_set_nonblocking", 
            "text": "void  quiet_decoder_set_nonblocking ( quiet_decoder   * d );   quiet_decoder_set_nonblocking changes the behavior of quiet_decoder_recv so that it will not block if it cannot read a frame. This function restores the default behavior after quiet_decoder_set_blocking has been called.", 
            "title": "quiet_decoder_set_nonblocking"
        }, 
        {
            "location": "/decoding/#parameters_3", 
            "text": "d  - decoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#quiet_decoder_consume", 
            "text": "void  quiet_decoder_consume ( quiet_decoder   * d , \n\n                       const   quiet_sample_t   * samplebuf , \n\n                       size_t   sample_len );   quiet_decoder_consume consumes sound samples and decodes them to frames. These can be samples obtained directly from a sound file, a soundcard's microphone, or any other source which can receive quiet_sample_t (float).  If you are using a soundcard, it is recommended to use the largest block size offered. Typically, this is 16384 samples. Larger block sizes will help hide uneven latencies in the decoding process and ensure smoother reception at the cost of longer latencies.", 
            "title": "quiet_decoder_consume"
        }, 
        {
            "location": "/decoding/#parameters_4", 
            "text": "d  - decoder object  samplebuf  - array of samples received from sound card  sample_len  - number of samples in samplebuf", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#quiet_decoder_frame_in_progress", 
            "text": "bool  quiet_decoder_frame_in_progress ( quiet_decoder   * d );   quiet_decoder_frame_in_progress determines if a frame is likely in the process of being received. It inspects information in the decoding process and will be relevant to the last call to quiet_decoder_consume. There is no guarantee of accuracy from this function, and both false-negatives and false-positives can occur.  The output of this function can be useful to avoid collisions when two pairs of encoders/decoders share the same channel, e.g. in half-duplex.  This function must be called from the same thread which calls quiet_decoder_consume.", 
            "title": "quiet_decoder_frame_in_progress"
        }, 
        {
            "location": "/decoding/#parameters_5", 
            "text": "d  - decoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#returns_2", 
            "text": "true if a frame is likely being received", 
            "title": "Returns"
        }, 
        {
            "location": "/decoding/#quiet_decoder_flush", 
            "text": "void  quiet_decoder_flush ( quiet_decoder   * d );   quiet_decoder_flush empties out all internal buffers and attempts to decode them  This function need only be called after the sound stream has stopped. It is especially useful for reading from sound files where there are no trailing samples to \"push\" the decoded data through the decoder's filters", 
            "title": "quiet_decoder_flush"
        }, 
        {
            "location": "/decoding/#parameters_6", 
            "text": "d  - decoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#quiet_decoder_close", 
            "text": "void  quiet_decoder_close ( quiet_decoder   * d );   quiet_decoder_close closes the decoder object. Future calls to quiet_decoder_consume will still attempt the decoding process but will not enqueue any decoded frames into the receive queue, e.g. they become cpu-expensive no-ops. Any previously enqueued frames can still be read out by quiet_decoder_recv, and once the receive queue is empty, quiet_decoder_recv will set the last error to quiet_closed.", 
            "title": "quiet_decoder_close"
        }, 
        {
            "location": "/decoding/#parameters_7", 
            "text": "d  - decoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#quiet_decoder_checksum_fails", 
            "text": "unsigned   int  quiet_decoder_checksum_fails ( const   quiet_decoder   * d );   quiet_decoder_checksum_fails returns the total number of frames decoded but which failed checksum across the lifetime of the decoder.", 
            "title": "quiet_decoder_checksum_fails"
        }, 
        {
            "location": "/decoding/#parameters_8", 
            "text": "d  - decoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#returns_3", 
            "text": "Total number of frames received with failed checksums", 
            "title": "Returns"
        }, 
        {
            "location": "/decoding/#quiet_decoder_consume_stats", 
            "text": "const   quiet_decoder_frame_stats   *  quiet_decoder_consume_stats ( quiet_decoder   * d , \n\n                             size_t   * num_frames );   quiet_decoder_consume_stats returns detailed info about the decoding process from the last call to quiet_decoder_consume_stats. It will save information on up to 8 frames. This includes frames which failed checksum. If quiet_decoder_consume found more than 8 frames, then information on only the first 8 frames will be saved.  In order to use this functionality, quiet_decoder_enable_stats must be called on the decoder object before calling quiet_decoder_consume.  This function must be called from the same thread that calls quiet_decoder_consume.", 
            "title": "quiet_decoder_consume_stats"
        }, 
        {
            "location": "/decoding/#parameters_9", 
            "text": "d  - decoder object  num_frames  - number of frames at returned pointer", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#returns_4", 
            "text": "quiet_decoder_frame_stats  which is an array of structs containing stats info, num_frames long", 
            "title": "Returns"
        }, 
        {
            "location": "/decoding/#quiet_decoder_recv_stats", 
            "text": "const   quiet_decoder_frame_stats   *  quiet_decoder_recv_stats ( quiet_decoder   * d );", 
            "title": "quiet_decoder_recv_stats"
        }, 
        {
            "location": "/decoding/#quiet_decoder_enable_stats", 
            "text": "void  quiet_decoder_enable_stats ( quiet_decoder   * d );   quiet_decoder_enable_stats allocates the required memory needed to save symbol and other information on each frame decode. Italso adds a small overhead needed to copy this information into an internal buffer.  By default, stats collection is disabled. Therefore, if the user would like to use quiet_decoder_consume_stats, then they must first call quiet_decoder_enable_stats.", 
            "title": "quiet_decoder_enable_stats"
        }, 
        {
            "location": "/decoding/#parameters_10", 
            "text": "d  - decoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#quiet_decoder_disable_stats", 
            "text": "void  quiet_decoder_disable_stats ( quiet_decoder   * d );   quiet_decoder_disable_stats frees all memory associated with stats collection.", 
            "title": "quiet_decoder_disable_stats"
        }, 
        {
            "location": "/decoding/#parameters_11", 
            "text": "d  - decoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/decoding/#quiet_decoder_set_stats_blocking", 
            "text": "void  quiet_decoder_set_stats_blocking ( quiet_decoder   * d , \n\n                                  time_t   sec , \n\n                                  long   nano );", 
            "title": "quiet_decoder_set_stats_blocking"
        }, 
        {
            "location": "/decoding/#quiet_decoder_set_stats_nonblocking", 
            "text": "void  quiet_decoder_set_stats_nonblocking ( quiet_decoder   * d );", 
            "title": "quiet_decoder_set_stats_nonblocking"
        }, 
        {
            "location": "/decoding/#quiet_decoder_destroy", 
            "text": "void  quiet_decoder_destroy ( quiet_decoder   * d );   quiet_decoder_destroy releases all resources allocated by the  quiet_decoder . After calling this function, the user should not call any other decoder functions on the decoder.", 
            "title": "quiet_decoder_destroy"
        }, 
        {
            "location": "/decoding/#parameters_12", 
            "text": "d  - decoder object", 
            "title": "Parameters"
        }, 
        {
            "location": "/profiles/", 
            "text": "Profiles\n\n\nProfiles are the configuration system of Quiet Modem. A single profile sets all of the parameters for both the transmitter and the receiver. Quiet uses a JSON-based serialization for profiles, and any given profile works across all Quiet platforms.\n\n\nQuiet comes with some starter profiles. These can be used out of the box with good success in a variety of use cases. They will also make a good starting point for more tuning and testing, should you decide to tweak Quiet to fit your use case specifically.\n\n\nStructure\n\n\nProfiles are stored in a file called \nquiet-profiles.json\n. Inside this file is a single JSON object. The top-level keys of this object are names of profiles, e.g. \nultrasonic-whisper\n. The corresponding value for this key contains another object which provides a complete profile for Quiet's transmitter and receiver.\n\n\nQuiet Profile Lab\n\n\nThe \nQuiet Profile Lab\n is an interactive testbench that runs in your browser. This allows you to test out new profiles with the speakers and mic in your computer. The Lab has instrumentation that can help you understand how various options change Quiet's behavior.\n\n\nmod_scheme\n\n\nThis sets the payload modulation mode for Quiet. Most methods come in a variety of bit depths.\n\n\nGaussian Minimum Shift Keying \nwikipedia\n\n\nThis mode is selected with \nmod_scheme\n set to \ngmsk\n. This mode is not compatible with OFDM operation.\n\n\nPhase Shift Keying \nwikipedia\n\n\nThis method can be pictured as a unit circle in the complex plane. Each bit representation contains the same magnitude and varies only in phase on this unit circle.\n\n\nComes in \npsk2\n, \npsk4\n, \npsk8\n, \npsk16\n, \npsk32\n, \npsk64\n, \npsk128\n, \npsk256\n variants.\n\n\nDifferential Phase Shift Keying \nwikipedia\n\n\nThis modulation method has the same constellation as PSK, but modulates changes in subsequent bits rather than the bits themselves.\n\n\nComes in \ndpsk2\n, \ndpsk4\n, \ndpsk8\n, \ndpsk16\n, \ndpsk32\n, \ndpsk64\n, \ndpsk128\n, \ndpsk256\n variants.\n\n\nAmplitude Shift Keying \nwikipedia\n\n\nThis modulation scheme uses only the real axis of the complex plane. Bits are encoded as various amplitude levels on the carrier signal.\n\n\nComes in \nask2\n, \nask4\n, \nask8\n, \nask16\n, \nask32\n, \nask64\n, \nask128\n, \nask256\n variants.\n\n\nAmplitude Phase Shift Keying \nwikipedia\n\n\nThis scheme can be pictured as concentric circles on the complex plane. Greater amplitude values move modulation out to a larger circle, while changes in phase move to different points along the circle.\n\n\nComes in \napsk2\n, \napsk4\n, \napsk8\n, \napsk16\n, \napsk32\n, \napsk64\n, \napsk128\n, \napsk256\n variants.\n\n\nQuadrature Amplitude Shift Keying \nwikipedia\n\n\nThis modulation scheme uses a grid of points in the complex plane. Each symbol corresponds to a point along the grid.\n\n\nComes in \nqam2\n, \nqam4\n, \nqam8\n, \nqam16\n, \nqam32\n, \nqam64\n, \nqam128\n, \nqam256\n, \nqam512\n, \nqam1024\n, \nqam2048\n, \nqam4096\n variants.\n\n\nOptimal QASK\n\n\nMiscellaneous\n\n\nofdm\n\n\nofdm.num_subcarriers\n\n\nofdm.cyclic_prefx_length\n\n\nofdm.taper_length\n\n\nofdm.left_band\n\n\nofdm.right_band\n\n\nchecksum_scheme\n\n\nChecksum \nwikipedia\n\n\nCyclic redundancy check \nwikipedia\n\n\ninner_fec_scheme\n\n\nRepetition Code \nwikipedia\n\n\nHamming \nwikipedia\n\n\nGolay \nwikipedia\n\n\nSECDED \nwikipedia\n\n\nConvolutional Codes \nwikipedia\n\n\nReed-Solomon \nwikipedia\n\n\nouter_fec_scheme\n\n\nThis accepts the same values as \ninner_fec_scheme\n.\n\n\nframe_length\n\n\nmodulation\n\n\nmodulation.center_frequency\n\n\nmodulation.gain\n\n\ninterpolation\n\n\ninterpolation.shape\n\n\nrrcos\n\n\ninterpolation.samples_per_symbol\n\n\ninterpolation.symbol_delay\n\n\ninterpolation.excess_bandwidth\n\n\nencoder_filters\n\n\nencoder_filters.dc_filter_alpha\n\n\nresampler\n\n\nresampler.delay\n\n\nresampler.bandwidth\n\n\nresampler.attenuation\n\n\nresampler.filter_bank_size", 
            "title": "Profiles"
        }, 
        {
            "location": "/profiles/#profiles", 
            "text": "Profiles are the configuration system of Quiet Modem. A single profile sets all of the parameters for both the transmitter and the receiver. Quiet uses a JSON-based serialization for profiles, and any given profile works across all Quiet platforms.  Quiet comes with some starter profiles. These can be used out of the box with good success in a variety of use cases. They will also make a good starting point for more tuning and testing, should you decide to tweak Quiet to fit your use case specifically.", 
            "title": "Profiles"
        }, 
        {
            "location": "/profiles/#structure", 
            "text": "Profiles are stored in a file called  quiet-profiles.json . Inside this file is a single JSON object. The top-level keys of this object are names of profiles, e.g.  ultrasonic-whisper . The corresponding value for this key contains another object which provides a complete profile for Quiet's transmitter and receiver.", 
            "title": "Structure"
        }, 
        {
            "location": "/profiles/#quiet-profile-lab", 
            "text": "The  Quiet Profile Lab  is an interactive testbench that runs in your browser. This allows you to test out new profiles with the speakers and mic in your computer. The Lab has instrumentation that can help you understand how various options change Quiet's behavior.", 
            "title": "Quiet Profile Lab"
        }, 
        {
            "location": "/profiles/#mod_scheme", 
            "text": "This sets the payload modulation mode for Quiet. Most methods come in a variety of bit depths.", 
            "title": "mod_scheme"
        }, 
        {
            "location": "/profiles/#gaussian-minimum-shift-keying-wikipedia", 
            "text": "This mode is selected with  mod_scheme  set to  gmsk . This mode is not compatible with OFDM operation.", 
            "title": "Gaussian Minimum Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#phase-shift-keying-wikipedia", 
            "text": "This method can be pictured as a unit circle in the complex plane. Each bit representation contains the same magnitude and varies only in phase on this unit circle.  Comes in  psk2 ,  psk4 ,  psk8 ,  psk16 ,  psk32 ,  psk64 ,  psk128 ,  psk256  variants.", 
            "title": "Phase Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#differential-phase-shift-keying-wikipedia", 
            "text": "This modulation method has the same constellation as PSK, but modulates changes in subsequent bits rather than the bits themselves.  Comes in  dpsk2 ,  dpsk4 ,  dpsk8 ,  dpsk16 ,  dpsk32 ,  dpsk64 ,  dpsk128 ,  dpsk256  variants.", 
            "title": "Differential Phase Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#amplitude-shift-keying-wikipedia", 
            "text": "This modulation scheme uses only the real axis of the complex plane. Bits are encoded as various amplitude levels on the carrier signal.  Comes in  ask2 ,  ask4 ,  ask8 ,  ask16 ,  ask32 ,  ask64 ,  ask128 ,  ask256  variants.", 
            "title": "Amplitude Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#amplitude-phase-shift-keying-wikipedia", 
            "text": "This scheme can be pictured as concentric circles on the complex plane. Greater amplitude values move modulation out to a larger circle, while changes in phase move to different points along the circle.  Comes in  apsk2 ,  apsk4 ,  apsk8 ,  apsk16 ,  apsk32 ,  apsk64 ,  apsk128 ,  apsk256  variants.", 
            "title": "Amplitude Phase Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#quadrature-amplitude-shift-keying-wikipedia", 
            "text": "This modulation scheme uses a grid of points in the complex plane. Each symbol corresponds to a point along the grid.  Comes in  qam2 ,  qam4 ,  qam8 ,  qam16 ,  qam32 ,  qam64 ,  qam128 ,  qam256 ,  qam512 ,  qam1024 ,  qam2048 ,  qam4096  variants.", 
            "title": "Quadrature Amplitude Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#optimal-qask", 
            "text": "", 
            "title": "Optimal QASK"
        }, 
        {
            "location": "/profiles/#miscellaneous", 
            "text": "", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/profiles/#ofdm", 
            "text": "", 
            "title": "ofdm"
        }, 
        {
            "location": "/profiles/#ofdmnum_subcarriers", 
            "text": "", 
            "title": "ofdm.num_subcarriers"
        }, 
        {
            "location": "/profiles/#ofdmcyclic_prefx_length", 
            "text": "", 
            "title": "ofdm.cyclic_prefx_length"
        }, 
        {
            "location": "/profiles/#ofdmtaper_length", 
            "text": "", 
            "title": "ofdm.taper_length"
        }, 
        {
            "location": "/profiles/#ofdmleft_band", 
            "text": "", 
            "title": "ofdm.left_band"
        }, 
        {
            "location": "/profiles/#ofdmright_band", 
            "text": "", 
            "title": "ofdm.right_band"
        }, 
        {
            "location": "/profiles/#checksum_scheme", 
            "text": "", 
            "title": "checksum_scheme"
        }, 
        {
            "location": "/profiles/#checksum-wikipedia", 
            "text": "", 
            "title": "Checksum wikipedia"
        }, 
        {
            "location": "/profiles/#cyclic-redundancy-check-wikipedia", 
            "text": "", 
            "title": "Cyclic redundancy check wikipedia"
        }, 
        {
            "location": "/profiles/#inner_fec_scheme", 
            "text": "", 
            "title": "inner_fec_scheme"
        }, 
        {
            "location": "/profiles/#repetition-code-wikipedia", 
            "text": "", 
            "title": "Repetition Code wikipedia"
        }, 
        {
            "location": "/profiles/#hamming-wikipedia", 
            "text": "", 
            "title": "Hamming wikipedia"
        }, 
        {
            "location": "/profiles/#golay-wikipedia", 
            "text": "", 
            "title": "Golay wikipedia"
        }, 
        {
            "location": "/profiles/#secded-wikipedia", 
            "text": "", 
            "title": "SECDED wikipedia"
        }, 
        {
            "location": "/profiles/#convolutional-codes-wikipedia", 
            "text": "", 
            "title": "Convolutional Codes wikipedia"
        }, 
        {
            "location": "/profiles/#reed-solomon-wikipedia", 
            "text": "", 
            "title": "Reed-Solomon wikipedia"
        }, 
        {
            "location": "/profiles/#outer_fec_scheme", 
            "text": "This accepts the same values as  inner_fec_scheme .", 
            "title": "outer_fec_scheme"
        }, 
        {
            "location": "/profiles/#frame_length", 
            "text": "", 
            "title": "frame_length"
        }, 
        {
            "location": "/profiles/#modulation", 
            "text": "", 
            "title": "modulation"
        }, 
        {
            "location": "/profiles/#modulationcenter_frequency", 
            "text": "", 
            "title": "modulation.center_frequency"
        }, 
        {
            "location": "/profiles/#modulationgain", 
            "text": "", 
            "title": "modulation.gain"
        }, 
        {
            "location": "/profiles/#interpolation", 
            "text": "", 
            "title": "interpolation"
        }, 
        {
            "location": "/profiles/#interpolationshape", 
            "text": "", 
            "title": "interpolation.shape"
        }, 
        {
            "location": "/profiles/#rrcos", 
            "text": "", 
            "title": "rrcos"
        }, 
        {
            "location": "/profiles/#interpolationsamples_per_symbol", 
            "text": "", 
            "title": "interpolation.samples_per_symbol"
        }, 
        {
            "location": "/profiles/#interpolationsymbol_delay", 
            "text": "", 
            "title": "interpolation.symbol_delay"
        }, 
        {
            "location": "/profiles/#interpolationexcess_bandwidth", 
            "text": "", 
            "title": "interpolation.excess_bandwidth"
        }, 
        {
            "location": "/profiles/#encoder_filters", 
            "text": "", 
            "title": "encoder_filters"
        }, 
        {
            "location": "/profiles/#encoder_filtersdc_filter_alpha", 
            "text": "", 
            "title": "encoder_filters.dc_filter_alpha"
        }, 
        {
            "location": "/profiles/#resampler", 
            "text": "", 
            "title": "resampler"
        }, 
        {
            "location": "/profiles/#resamplerdelay", 
            "text": "", 
            "title": "resampler.delay"
        }, 
        {
            "location": "/profiles/#resamplerbandwidth", 
            "text": "", 
            "title": "resampler.bandwidth"
        }, 
        {
            "location": "/profiles/#resamplerattenuation", 
            "text": "", 
            "title": "resampler.attenuation"
        }, 
        {
            "location": "/profiles/#resamplerfilter_bank_size", 
            "text": "", 
            "title": "resampler.filter_bank_size"
        }, 
        {
            "location": "/errors/", 
            "text": "Errors\n\n\nquiet_error\n\n\ntypedef\n \nenum\n \n{\n\n\n    \nquiet_success\n,\n\n\n    \nquiet_mem_fail\n,\n\n\n    \nquiet_encoder_bad_config\n,\n\n\n    \nquiet_profile_malformed_json\n,\n\n\n    \nquiet_profile_missing_key\n,\n\n\n    \nquiet_profile_invalid_profile\n,\n\n\n    \nquiet_msg_size\n,\n\n\n    \nquiet_would_block\n,\n\n\n    \nquiet_timedout\n,\n\n\n    \nquiet_io\n\n\n\n}\n \nquiet_error\n;\n\n\n\n\n\n\nquiet_success\n\n\nquiet_mem_fail\n\n\nquiet_encoder_bad_config\n\n\nquiet_profile_malformed_json\n\n\nquiet_profile_missing_key\n\n\nquiet_profile_invalid_profile\n\n\nquiet_msg_size\n\n\nquiet_would_block\n\n\nquiet_timedout\n\n\nquiet_io\n\n\nquiet_get_last_error\n\n\nquiet_error\n\n\n\nquiet_get_last_error\n();\n\n\n\n\n\n\nquiet_get_last_error retrieves the last error set. If libquiet was compiled with pthread, then this error will be specific to the thread where this is called.", 
            "title": "Errors"
        }, 
        {
            "location": "/errors/#errors", 
            "text": "", 
            "title": "Errors"
        }, 
        {
            "location": "/errors/#quiet_error", 
            "text": "typedef   enum   { \n\n     quiet_success , \n\n     quiet_mem_fail , \n\n     quiet_encoder_bad_config , \n\n     quiet_profile_malformed_json , \n\n     quiet_profile_missing_key , \n\n     quiet_profile_invalid_profile , \n\n     quiet_msg_size , \n\n     quiet_would_block , \n\n     quiet_timedout , \n\n     quiet_io  }   quiet_error ;", 
            "title": "quiet_error"
        }, 
        {
            "location": "/errors/#quiet_success", 
            "text": "", 
            "title": "quiet_success"
        }, 
        {
            "location": "/errors/#quiet_mem_fail", 
            "text": "", 
            "title": "quiet_mem_fail"
        }, 
        {
            "location": "/errors/#quiet_encoder_bad_config", 
            "text": "", 
            "title": "quiet_encoder_bad_config"
        }, 
        {
            "location": "/errors/#quiet_profile_malformed_json", 
            "text": "", 
            "title": "quiet_profile_malformed_json"
        }, 
        {
            "location": "/errors/#quiet_profile_missing_key", 
            "text": "", 
            "title": "quiet_profile_missing_key"
        }, 
        {
            "location": "/errors/#quiet_profile_invalid_profile", 
            "text": "", 
            "title": "quiet_profile_invalid_profile"
        }, 
        {
            "location": "/errors/#quiet_msg_size", 
            "text": "", 
            "title": "quiet_msg_size"
        }, 
        {
            "location": "/errors/#quiet_would_block", 
            "text": "", 
            "title": "quiet_would_block"
        }, 
        {
            "location": "/errors/#quiet_timedout", 
            "text": "", 
            "title": "quiet_timedout"
        }, 
        {
            "location": "/errors/#quiet_io", 
            "text": "", 
            "title": "quiet_io"
        }, 
        {
            "location": "/errors/#quiet_get_last_error", 
            "text": "quiet_error  quiet_get_last_error ();   quiet_get_last_error retrieves the last error set. If libquiet was compiled with pthread, then this error will be specific to the thread where this is called.", 
            "title": "quiet_get_last_error"
        }, 
        {
            "location": "/frame-stats/", 
            "text": "Frame Stats\n\n\nquiet_decoder_frame_stats\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nconst\n \nquiet_complex\n \n*\n \nsymbols\n;\n\n\n    \nsize_t\n \nnum_symbols\n;\n\n\n    \nfloat\n \nerror_vector_magnitude\n;\n\n\n    \nfloat\n \nreceived_signal_strength_indicator\n;\n\n\n    \nbool\n \nchecksum_passed\n;\n\n\n\n}\n \nquiet_decoder_frame_stats\n;\n\n\n\n\n\n\nThis contains information about the decoding process related to a single frame. The frame may have been detected but failed to pass checksum or may have been successfully received.\n\n\nsymbols\n\n\nRaw symbols, in complex plane, as seen after decimation and downmixing.\n\n\nnum_symbols\n\n\nerror_vector_magnitude\n\n\nMagnitude of vector from received symbols to reference symbols, in dB.\n\n\nreceived_signal_strength_indicator\n\n\nPower level of received signal after decimation and downmixing, in dB.\n\n\nchecksum_passed\n\n\nquiet_complex\n\n\ntypedef\n \nstruct\n \n{\n\n\n    \nfloat\n \nreal\n;\n\n\n    \nfloat\n \nimaginary\n;\n\n\n\n}\n \nquiet_complex\n;\n\n\n\n\n\n\nreal\n\n\nimaginary", 
            "title": "Frame Stats"
        }, 
        {
            "location": "/frame-stats/#frame-stats", 
            "text": "", 
            "title": "Frame Stats"
        }, 
        {
            "location": "/frame-stats/#quiet_decoder_frame_stats", 
            "text": "typedef   struct   { \n\n     const   quiet_complex   *   symbols ; \n\n     size_t   num_symbols ; \n\n     float   error_vector_magnitude ; \n\n     float   received_signal_strength_indicator ; \n\n     bool   checksum_passed ;  }   quiet_decoder_frame_stats ;   This contains information about the decoding process related to a single frame. The frame may have been detected but failed to pass checksum or may have been successfully received.", 
            "title": "quiet_decoder_frame_stats"
        }, 
        {
            "location": "/frame-stats/#symbols", 
            "text": "Raw symbols, in complex plane, as seen after decimation and downmixing.", 
            "title": "symbols"
        }, 
        {
            "location": "/frame-stats/#num_symbols", 
            "text": "", 
            "title": "num_symbols"
        }, 
        {
            "location": "/frame-stats/#error_vector_magnitude", 
            "text": "Magnitude of vector from received symbols to reference symbols, in dB.", 
            "title": "error_vector_magnitude"
        }, 
        {
            "location": "/frame-stats/#received_signal_strength_indicator", 
            "text": "Power level of received signal after decimation and downmixing, in dB.", 
            "title": "received_signal_strength_indicator"
        }, 
        {
            "location": "/frame-stats/#checksum_passed", 
            "text": "", 
            "title": "checksum_passed"
        }, 
        {
            "location": "/frame-stats/#quiet_complex", 
            "text": "typedef   struct   { \n\n     float   real ; \n\n     float   imaginary ;  }   quiet_complex ;", 
            "title": "quiet_complex"
        }, 
        {
            "location": "/frame-stats/#real", 
            "text": "", 
            "title": "real"
        }, 
        {
            "location": "/frame-stats/#imaginary", 
            "text": "", 
            "title": "imaginary"
        }
    ]
}