{
    "docs": [
        {
            "location": "/", 
            "text": "Quiet Modem Project\n\n\nQuiet Modem Project is an easy way to provide low-throughput communication for websites and apps without requiring access to Internet or pairing between two devices. It is a set of cross-platform libraries that allow you to encode data as sound and transmit it with a speaker. A device or application with the Quiet Modem can then detect this sound and receive the encoded data. This sound can be audible or nearly ultrasonic. \nForward Error Correction\n applied to the message helps preserve the data against errors in transmission, while \nChecksums\n discard messages received incorrectly.\n\n\nLive Demo\n\n\n\n\nAll of the Quiet Modem's libraries, and its dependencies, are licensed under a mix of BSD and MIT, allowing a versatile range of use cases. Quiet's source is freely available and can be audited, which ensures that your user's microphone data is safe. Quiet Modem is offered in \nC\n, \nJavascript\n, \nAndroid\n and \niOS\n. It provides bindings to soundcards on each platform so that you can simply encode data on one side and decode on the other.\n\n\nThe Quiet Modem is configured with a JSON-based profile system that allows you to change a wide range of behaviors at runtime. Quiet is built on top of a \nhighly capable DSP/SDR library\n which provides it with good robustness, even at distances up to 1 meter.", 
            "title": "Quiet Modem"
        }, 
        {
            "location": "/#quiet-modem-project", 
            "text": "Quiet Modem Project is an easy way to provide low-throughput communication for websites and apps without requiring access to Internet or pairing between two devices. It is a set of cross-platform libraries that allow you to encode data as sound and transmit it with a speaker. A device or application with the Quiet Modem can then detect this sound and receive the encoded data. This sound can be audible or nearly ultrasonic.  Forward Error Correction  applied to the message helps preserve the data against errors in transmission, while  Checksums  discard messages received incorrectly.", 
            "title": "Quiet Modem Project"
        }, 
        {
            "location": "/#live-demo", 
            "text": "All of the Quiet Modem's libraries, and its dependencies, are licensed under a mix of BSD and MIT, allowing a versatile range of use cases. Quiet's source is freely available and can be audited, which ensures that your user's microphone data is safe. Quiet Modem is offered in  C ,  Javascript ,  Android  and  iOS . It provides bindings to soundcards on each platform so that you can simply encode data on one side and decode on the other.  The Quiet Modem is configured with a JSON-based profile system that allows you to change a wide range of behaviors at runtime. Quiet is built on top of a  highly capable DSP/SDR library  which provides it with good robustness, even at distances up to 1 meter.", 
            "title": "Live Demo"
        }, 
        {
            "location": "/setup/", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/example/", 
            "text": "", 
            "title": "Example"
        }, 
        {
            "location": "/transmitting/", 
            "text": "Transmitting Data", 
            "title": "Transmitting Data"
        }, 
        {
            "location": "/transmitting/#transmitting-data", 
            "text": "", 
            "title": "Transmitting Data"
        }, 
        {
            "location": "/receiving/", 
            "text": "Receiving Data\n\n\nCreating Receiver\n\n\nReceiving Data\n\n\nCallbacks\n\n\nReceiver Stats\n\n\nShutting Down\n\n\nRaw Sample Decoder", 
            "title": "Receiving Data"
        }, 
        {
            "location": "/receiving/#receiving-data", 
            "text": "", 
            "title": "Receiving Data"
        }, 
        {
            "location": "/receiving/#creating-receiver", 
            "text": "", 
            "title": "Creating Receiver"
        }, 
        {
            "location": "/receiving/#receiving-data_1", 
            "text": "", 
            "title": "Receiving Data"
        }, 
        {
            "location": "/receiving/#callbacks", 
            "text": "", 
            "title": "Callbacks"
        }, 
        {
            "location": "/receiving/#receiver-stats", 
            "text": "", 
            "title": "Receiver Stats"
        }, 
        {
            "location": "/receiving/#shutting-down", 
            "text": "", 
            "title": "Shutting Down"
        }, 
        {
            "location": "/receiving/#raw-sample-decoder", 
            "text": "", 
            "title": "Raw Sample Decoder"
        }, 
        {
            "location": "/how/", 
            "text": "How It Works\n\n\nQuiet Modem encodes your data into sound that can be played by your speakers. These sounds can then be detected through a microphone and converted back into data.\n\n\nThis section of the documentation is optional. It can be skipped if you just wish to begin using the modem. However, if you need to debug your modem, it can be helpful to understand how these libraries work.\n\n\nSoundcard\n\n\n\n\nIn order to understand what it means to play sound, it helps to first demonstrate how your sounds work within your computer. When we want to represent a sound, we sample it at periodic intervals in time. Each sample is rounded to one of thousands of discrete intensity levels in a process known as \nPulse-Code Modulation\n. We refer to the number of samples represented in a single second as the sample rate. The most common sample rate for digital audio is 44,100 Hz (samples per second). The sample rate applies both to sounds that we want to play and sounds that we are recording. The computer has a sound card or chip which is responsible for converting analog sounds to digital samples and vice versa.\n\n\nQuiet Modem operates internally at the sample rate of 44,100 Hz. Each sample is generated as a 32-bit floating-point value between -1 and 1. In fact, Quiet can operate across any channel that can transmit these floating point numbers, though the degree of success will depend on how much the samples are distorted after they are transmitted.\n\n\nModulation\n\n\n\n\n\n\nAs described in the section on soundcards, we will be operating on individual samples of sound. We know that we will be sending and receiving individual samples, each of which can be assigned a single floating-point value. We also know that these values will eventually have to be played as analog electrical signals which excite sounds through a speaker. We will convert data to sample values through a process known as modulation.\n\n\nQuiet Modem uses \nLiquid SDR\n to do the heavily lifting for its modulation tasks. This section is describing mostly how parts of Liquid work. The key points are repeated in this documentation so that users of Quiet should not have to rely too heavily on Liquid's documentation.\n\n\nFraming\n\n\nQuiet Modem sends data in chunks, which we will call frames. Each frame can be thought of as a completely self-contained packet of data. The start of each frame contains a synchronization sequence that allows the receiver to have a good chance of decoding the frame. Quiet performs checksumming on the contents of each frame so that it can discard frames that have picked up errors in transmission.\n\n\nA single frame of data has a maxium payload size that it can carry. This size will depend on the specific configuration used, but in general, a frame will be converted into at most one or two seconds of sound. Frames that are longer than this are more likely to encounter errors.\n\n\n\n\nIt is up to the user of Quiet's libraries to split data into frames.\n Quiet will discard frames that are longer than the configured transmitter's maximum frame length. Although this is somewhat inconvenient, the upside is that frames are given back to the user in the same structure when received. This means that if you wish to use e.g. the first byte of each frame to signal when a message is starting or ending, you will always be able to find this marker at the first byte.\n\n\n\n\nChecksum\n\n\nQuiet offers automatic \nchecksum verification\n of frames. The strongest of these methods offered is \nCRC32\n which will fail nearly every time if even a single bit in the received frame is incorrect. Some applications may wish to disable checksums if receiving an incorrect message is preferable to receiving no message.\n\n\nFor this step, Quiet generates the checksum and then sets it aside for later. The checksum itself will be passed in a different part of the frame from where the user payload goes.\n\n\nError Correction\n\n\nBefore we modulate our frame, we can add redundancy to it. This redundancy allows the receiver to recover our original message even when some errors occur in transmission. This process is known as \nForward Error Correction\n.\n\n\nAs an example, you can imagine that we repeat each bit of our message three times. Then when the receiver receives this message, it picks whichever bit occurs most often \n if two of these three bits are '0' and one is '1', then we pick '0' as the original message bit.\n\n\nModern forward error correction is more sophisticated than simply repeating bits, but, as a consequence, not as easy to explain. Quiet Modem relies on the modes provided by Liquid SDR. In particular, it makes use of \nConvolutional Codes\n and \nReed-Solomon\n. Once we apply these methods to our original message, we take the resulting bits and pass them on to our modulator.\n\n\nPayload Modulator\n\n\nLiquid SDR offers a wide range of modulation options, and so it is beyond the scope of this page to fully explain all of them. If you are curious which specific options Quiet provides, the documentation on \nProfiles\n offers more details. Quiet makes use of Liquid's standard modems, OFDM and GMSK modes. For this section, we will explore one of the most basic modes, BPSK.\n\n\nIn \nbinary phase-shift keying\n, we assign each bit of the message we want to send into a sequence of floating-point samples. Each sample will represent a single bit of data. If we want to send a binary '0', then we create a new sample with a floating-point value of -1.0. If we instead want to send binary '1', then we assign the value of 1.0. Other modulation schemes can send more bits of data in each sample by picking more intermediate values, e.g. -0.5 and 0.5 and even \ncomplex values\n.\n\n\nWe now have floating-point samples where previously we had binary digits. If you were given the sequence created above, it would be easy to recover the original message. Unfortunately, we would not have much luck simply sending this sequence as it is. We will need to condition these samples so that they can deal with limitations in our real-world speaker. We will also need to make it easier for the receiver to find where our message starts.\n\n\nTransmitting\n\n\n\n\n\n\nJust as in our section on modulation, this section mostly describes functionality provided by Liquid DSP.\n\n\nPreamble\n\n\nOur receiver will be looking at a continuous stream of floating-point samples from the soundcard, waiting to see our message. These samples will contain all of the background noise near the microphone as well as whatever message we are sending. We need a way to tell the receiver that our message is about to begin so that it will know to interpret the samples it is seeing as message bits.\n\n\nThe way that we accomplish this is by using a predetermined, pseudorandom sequence of samples. We will start every message we send with this sequence so that the receiver will know unambiguously that our message is about to start. It will be much easier for the receiver to look for this specific sequence and then assume that the message follows immediately after. This sequence is known as the preamble. The preamble does \nnot\n need to be modulated \n the sequence itself is what we send.\n\n\nHeader\n\n\nThe header is a short block of data sent before the payload. The header contains information on which type of modulation and error correction are used in the payload. It also contains the actual checksum generated for the payload. A short checksum is sent for the contents of the header itself.\n\n\nHeader Modulator\n\n\nJust as our message was modulated to floating-point samples, we will apply error correction and modulation to the data in the header. The kinds used here can be different from the one used for the payload. We want the header to be especially reliable since an error in the header can make it impossible to receive the payload correctly.\n\n\nWe do not send the type of modulation or error correction used for the header itself. These values are pre-shared and are part of the modem configuration.\n\n\nAssembling the Frame\n\n\nWe now have all of the samples needed to send our frame. We start by sending the preamble samples, followed by the header samples, and finally the payload samples.\n\n\nInterpolation\n\n\nInterpolation is a process that allows us to restrict how quickly our signal changes values by inserting new 'fill' samples between each of our existing samples. We will fill in samples with values of 0 so that they do not change the overall energy in the signal. Next, all samples (original + fill) have their values smoothed out by evaluating a specially chosen polynomial that prefers slow changes in values over fast changes in values. In other words, we use a filter.\n\n\nThe new sequence of resulting samples will change less rapidly than the original, restricted to a narrower band of frequencies. The number of fill samples we choose allows us to control how much smaller the band gets. Inserting a single sample halves the range; inserting two reduces it to a third, and so on. Using a narrower frequency band will often give our data a better chance of being transmitted successfully. The downside is that it now takes us more samples to send the same message, which means our effective transmission speed is reduced.\n\n\nWe will apply this interpolation to the full contents of the frame, not just the part with our message.\n\n\nUpconversion\n\n\nOur interpolator reduced the bandwidth of our message, but the resulting waveform is very low frequency, centered at 0 Hz. Speakers do not work well at very low frequencies, so we will want to move our message out of that range through upconversion. Upconversion allows us to move the center of this transmission up to a new frequency, but with the same bandwidth as before upconversion.\n\n\nFor example, if our original transmission has a bandwidth of 4,000 Hz, and we upconvert it by 8,000 Hz, then it will sit at the range of 6,000 Hz to 10,000 Hz after upconversion.\n\n\nThis process is what allows us to go into the near-ultrasonic range. If we use interpolation to reduce our transmission be fairly narrow and then upconvert to 19kHz or so, the result will sit entirely above 18kHz, which is well above the hearing range for nearly everyone.\n\n\nGain Reduction\n\n\nThis step multiplies all values in the signal by some small fraction. This reduces the likelihood that the signal will clip beyond the acceptable range of [-1.0, 1.0], which our soundcard would reject. It also makes the transmission quieter so that it will be a reasonable volume regardless of how loud the user's volume settings are set to.\n\n\nBlock Buffer\n\n\nWe now have a stream of floating-point samples that is ready to be sent through the speaker. Soundcards expect to receive samples in blocks instead of one sample at a time. The soundcard's block length has to be preconfigured and some power of 2, commonly in the range of 256 (2^8) to 16384 (2^16). This step collects samples into bunches to match the soundcard's block length.\n\n\nIf too many samples are generated to fit into one block, Quiet sends one block's worth and stores the rest for the next block. If more samples are needed to fill a block, Quiet checks its send queue to see if more data frames are ready and fills with silence otherwise.\n\n\nReceiving\n\n\n\n\n\n\nThe receiver is running on a separate device from the transmitter. Here we will take samples collected by our microphone and decode the transmitted message.\n\n\nBlock Buffer\n\n\nThe soundcard will have collected floating-point samples of sound recorded by the microphone. These samples are sent to us in blocks made of multiple samples, just as when we sent samples to the speaker. Each block's length is a some power of 2.\n\n\nOur block buffer serves as a temporary store of samples as we run the decoding process.\n\n\nDownconversion\n\n\nWe have to invert the upconversion process so that the original signal's center is shifted back down to 0 Hz. This should be matched to the transmitter so that we shift down by the same frequency interval that we shifted up.\n\n\nDecimation\n\n\nThis step inverts interpolation. First we apply a low-pass filter to our signal and then we throw away samples. This should also be matched to the transmitter. For example, if we had chosen to interpolate by 2, now we will decimate by 2.\n\n\nFrame Detection\n\n\nThe resulting stream of samples should now resemble what we transmitted. When we sent our frame, we started it with a preamble. Now we will search for the preamble in the incoming samples. This is an ongoing process and will continue to run as long as no preamble is found.\n\n\nSynchronization and Equalization\n\n\nThe preamble is made up of a few different parts. The first part of the preamble is easily detectable so that we know where the frame begins. The next part of the preamble helps us synchronize our timing to the transmitter's timing in a precise way.\n\n\nFrom the section on Payload Modulation, we described how we convert binary data into floating-point amplitudes. One of the challenges we face in decoding is deciding at which point it will be appropriate to read these floating-point samples. The preamble helps us accomplish this by giving us a predictable sequence to look for. Even if noise is present on top of the preamble, we can still achieve a pretty good synchronization by looking for successive samples.\n\n\nWe will also use the preamble to compensate for the uneven frequency response of the transmit and receive channel. It is typical that our transmission channel will emphasize certain frequencies and attenuate others. We use the preamble to invert this bias introduced by the channel so that the signal we receive looks nearly flat again.\n\n\nDemodulate Header\n\n\nWith our clock aligned to the transmitter's, we are ready to begin decoding data. We start by decoding the modulated header samples. This data includes checksums of the payload and the header itself, as well as the type of modulation and error correection used in the payload. If the checksum of the decoded header data matches the checksum sent with the header, then we proceed to decoding the payload.\n\n\nDemodulation\n\n\n\n\n\n\nDemodulation\n\n\nUsing the demodulation method specified by the header, we now demodulate all of the frame's payload samples. We perform \nsoft demodulation\n so that the samples are demodulated into 8-bit \"soft\" bits. That is, for each bit of data transmitted, we now have an 8-bit value that reflects our belief about what might have been transmitted. A soft bit of 0 means that we are highly confident that a 0 was transmitted, 255 means that we are highly confident that a 1 was transmitted, and intermediate values mean we have some level of uncertainty. A value of 128 means that we believe either bit was equally likely. Preserving this level of uncertainty will help us during the error correction phase, as bits with lower confidence will accumulate less error.\n\n\nTo use our BPSK example from the modulation section, where we transmitted -1.0 for '0' and 1.0 for '1', imagine that we receive the sequence [0.9, -0.95, 0.1, 0.9]. If we were to decode these back to single bits, then we would decode this sequence as [1, 0, 1, 1]. However, if we use soft bits, we get [242, 6, 140, 242]. This better captures our uncertainty about the '0.1' sample we received, which is nearly as likely to be '0' as it is '1'.\n\n\nError Correction\n\n\nNow that we have the soft bits demodulated, our next step will be to apply the error correction techniques for the redundancy we added during modulation. The error correction will need to be good enough to decode the samples in spite of other noise occuring. Even the signal itself becomes noise, as echoes of the signal are picked up by the microphone.\n\n\nData Integrity\n\n\nFinally, we take the checksum value stored in the header and compare to a checksum of the data recovered after error correction. If these checksums match, we can be relatively confident that we have received the transmitted message. The bits can now be passed to the user.\n\n\nThe checksum stage is optional. Some applications may be well suited to receive messages with some errors. It is up to the user of Quiet Modem to decide whether to checksums should be used.\n\n\nThread Safety\n\n\n\n\nThe Quiet Modem library has some features that help it work well in a \nmultithreaded\n environment. In particular, Quiet assumes that the interface to the soundcard will run on a different thread than the user application. Quiet attempts to decouple its functionality so that it can be used in a threadsafe way.\n\n\nRing Buffer\n\n\nOne of the key components of Quiet's threadsafety is a \nring buffer\n that allows safe communication between threads. Quiet's ring buffer allows any number of readers and any number of writers. If the buffer is empty or full, it has mechanisms to allow readers and writers to block until data or space in the buffer is available.\n\n\nIn general, we try to keep frames of data in buffers, rather than modulated samples. This is because a modulated frame uses much more memory than the demodulated payload data.\n\n\nSend Queue\n\n\nOn the transmit side of Quiet, we use a ringbuffer to build a send queue. This allows senders to queue up packets for transmission as capacity allows. When the soundcard is ready for more samples, Quiet can read from the send queue and modulate one or more frames to fill up the soundcard buffer as necessary.\n\n\nReceive Queue\n\n\nOn the receive side of Quiet, we have a receive queue. Samples are continuously read from the microphone into Quiet's decoder. When it has successfully decoded a packet, the packet's payload is written as a complete frame into the receive queue. Users of Quiet can perform a blocking read of this queue which will wait until a frame is ready.\n\n\nQuiet.js\n\n\n\n\nEmscripten\n\n\nJavascript Wrapper", 
            "title": "How It Works"
        }, 
        {
            "location": "/how/#how-it-works", 
            "text": "Quiet Modem encodes your data into sound that can be played by your speakers. These sounds can then be detected through a microphone and converted back into data.  This section of the documentation is optional. It can be skipped if you just wish to begin using the modem. However, if you need to debug your modem, it can be helpful to understand how these libraries work.", 
            "title": "How It Works"
        }, 
        {
            "location": "/how/#soundcard", 
            "text": "In order to understand what it means to play sound, it helps to first demonstrate how your sounds work within your computer. When we want to represent a sound, we sample it at periodic intervals in time. Each sample is rounded to one of thousands of discrete intensity levels in a process known as  Pulse-Code Modulation . We refer to the number of samples represented in a single second as the sample rate. The most common sample rate for digital audio is 44,100 Hz (samples per second). The sample rate applies both to sounds that we want to play and sounds that we are recording. The computer has a sound card or chip which is responsible for converting analog sounds to digital samples and vice versa.  Quiet Modem operates internally at the sample rate of 44,100 Hz. Each sample is generated as a 32-bit floating-point value between -1 and 1. In fact, Quiet can operate across any channel that can transmit these floating point numbers, though the degree of success will depend on how much the samples are distorted after they are transmitted.", 
            "title": "Soundcard"
        }, 
        {
            "location": "/how/#modulation", 
            "text": "As described in the section on soundcards, we will be operating on individual samples of sound. We know that we will be sending and receiving individual samples, each of which can be assigned a single floating-point value. We also know that these values will eventually have to be played as analog electrical signals which excite sounds through a speaker. We will convert data to sample values through a process known as modulation.  Quiet Modem uses  Liquid SDR  to do the heavily lifting for its modulation tasks. This section is describing mostly how parts of Liquid work. The key points are repeated in this documentation so that users of Quiet should not have to rely too heavily on Liquid's documentation.", 
            "title": "Modulation"
        }, 
        {
            "location": "/how/#framing", 
            "text": "Quiet Modem sends data in chunks, which we will call frames. Each frame can be thought of as a completely self-contained packet of data. The start of each frame contains a synchronization sequence that allows the receiver to have a good chance of decoding the frame. Quiet performs checksumming on the contents of each frame so that it can discard frames that have picked up errors in transmission.  A single frame of data has a maxium payload size that it can carry. This size will depend on the specific configuration used, but in general, a frame will be converted into at most one or two seconds of sound. Frames that are longer than this are more likely to encounter errors.   It is up to the user of Quiet's libraries to split data into frames.  Quiet will discard frames that are longer than the configured transmitter's maximum frame length. Although this is somewhat inconvenient, the upside is that frames are given back to the user in the same structure when received. This means that if you wish to use e.g. the first byte of each frame to signal when a message is starting or ending, you will always be able to find this marker at the first byte.", 
            "title": "Framing"
        }, 
        {
            "location": "/how/#checksum", 
            "text": "Quiet offers automatic  checksum verification  of frames. The strongest of these methods offered is  CRC32  which will fail nearly every time if even a single bit in the received frame is incorrect. Some applications may wish to disable checksums if receiving an incorrect message is preferable to receiving no message.  For this step, Quiet generates the checksum and then sets it aside for later. The checksum itself will be passed in a different part of the frame from where the user payload goes.", 
            "title": "Checksum"
        }, 
        {
            "location": "/how/#error-correction", 
            "text": "Before we modulate our frame, we can add redundancy to it. This redundancy allows the receiver to recover our original message even when some errors occur in transmission. This process is known as  Forward Error Correction .  As an example, you can imagine that we repeat each bit of our message three times. Then when the receiver receives this message, it picks whichever bit occurs most often   if two of these three bits are '0' and one is '1', then we pick '0' as the original message bit.  Modern forward error correction is more sophisticated than simply repeating bits, but, as a consequence, not as easy to explain. Quiet Modem relies on the modes provided by Liquid SDR. In particular, it makes use of  Convolutional Codes  and  Reed-Solomon . Once we apply these methods to our original message, we take the resulting bits and pass them on to our modulator.", 
            "title": "Error Correction"
        }, 
        {
            "location": "/how/#payload-modulator", 
            "text": "Liquid SDR offers a wide range of modulation options, and so it is beyond the scope of this page to fully explain all of them. If you are curious which specific options Quiet provides, the documentation on  Profiles  offers more details. Quiet makes use of Liquid's standard modems, OFDM and GMSK modes. For this section, we will explore one of the most basic modes, BPSK.  In  binary phase-shift keying , we assign each bit of the message we want to send into a sequence of floating-point samples. Each sample will represent a single bit of data. If we want to send a binary '0', then we create a new sample with a floating-point value of -1.0. If we instead want to send binary '1', then we assign the value of 1.0. Other modulation schemes can send more bits of data in each sample by picking more intermediate values, e.g. -0.5 and 0.5 and even  complex values .  We now have floating-point samples where previously we had binary digits. If you were given the sequence created above, it would be easy to recover the original message. Unfortunately, we would not have much luck simply sending this sequence as it is. We will need to condition these samples so that they can deal with limitations in our real-world speaker. We will also need to make it easier for the receiver to find where our message starts.", 
            "title": "Payload Modulator"
        }, 
        {
            "location": "/how/#transmitting", 
            "text": "Just as in our section on modulation, this section mostly describes functionality provided by Liquid DSP.", 
            "title": "Transmitting"
        }, 
        {
            "location": "/how/#preamble", 
            "text": "Our receiver will be looking at a continuous stream of floating-point samples from the soundcard, waiting to see our message. These samples will contain all of the background noise near the microphone as well as whatever message we are sending. We need a way to tell the receiver that our message is about to begin so that it will know to interpret the samples it is seeing as message bits.  The way that we accomplish this is by using a predetermined, pseudorandom sequence of samples. We will start every message we send with this sequence so that the receiver will know unambiguously that our message is about to start. It will be much easier for the receiver to look for this specific sequence and then assume that the message follows immediately after. This sequence is known as the preamble. The preamble does  not  need to be modulated   the sequence itself is what we send.", 
            "title": "Preamble"
        }, 
        {
            "location": "/how/#header", 
            "text": "The header is a short block of data sent before the payload. The header contains information on which type of modulation and error correction are used in the payload. It also contains the actual checksum generated for the payload. A short checksum is sent for the contents of the header itself.", 
            "title": "Header"
        }, 
        {
            "location": "/how/#header-modulator", 
            "text": "Just as our message was modulated to floating-point samples, we will apply error correction and modulation to the data in the header. The kinds used here can be different from the one used for the payload. We want the header to be especially reliable since an error in the header can make it impossible to receive the payload correctly.  We do not send the type of modulation or error correction used for the header itself. These values are pre-shared and are part of the modem configuration.", 
            "title": "Header Modulator"
        }, 
        {
            "location": "/how/#assembling-the-frame", 
            "text": "We now have all of the samples needed to send our frame. We start by sending the preamble samples, followed by the header samples, and finally the payload samples.", 
            "title": "Assembling the Frame"
        }, 
        {
            "location": "/how/#interpolation", 
            "text": "Interpolation is a process that allows us to restrict how quickly our signal changes values by inserting new 'fill' samples between each of our existing samples. We will fill in samples with values of 0 so that they do not change the overall energy in the signal. Next, all samples (original + fill) have their values smoothed out by evaluating a specially chosen polynomial that prefers slow changes in values over fast changes in values. In other words, we use a filter.  The new sequence of resulting samples will change less rapidly than the original, restricted to a narrower band of frequencies. The number of fill samples we choose allows us to control how much smaller the band gets. Inserting a single sample halves the range; inserting two reduces it to a third, and so on. Using a narrower frequency band will often give our data a better chance of being transmitted successfully. The downside is that it now takes us more samples to send the same message, which means our effective transmission speed is reduced.  We will apply this interpolation to the full contents of the frame, not just the part with our message.", 
            "title": "Interpolation"
        }, 
        {
            "location": "/how/#upconversion", 
            "text": "Our interpolator reduced the bandwidth of our message, but the resulting waveform is very low frequency, centered at 0 Hz. Speakers do not work well at very low frequencies, so we will want to move our message out of that range through upconversion. Upconversion allows us to move the center of this transmission up to a new frequency, but with the same bandwidth as before upconversion.  For example, if our original transmission has a bandwidth of 4,000 Hz, and we upconvert it by 8,000 Hz, then it will sit at the range of 6,000 Hz to 10,000 Hz after upconversion.  This process is what allows us to go into the near-ultrasonic range. If we use interpolation to reduce our transmission be fairly narrow and then upconvert to 19kHz or so, the result will sit entirely above 18kHz, which is well above the hearing range for nearly everyone.", 
            "title": "Upconversion"
        }, 
        {
            "location": "/how/#gain-reduction", 
            "text": "This step multiplies all values in the signal by some small fraction. This reduces the likelihood that the signal will clip beyond the acceptable range of [-1.0, 1.0], which our soundcard would reject. It also makes the transmission quieter so that it will be a reasonable volume regardless of how loud the user's volume settings are set to.", 
            "title": "Gain Reduction"
        }, 
        {
            "location": "/how/#block-buffer", 
            "text": "We now have a stream of floating-point samples that is ready to be sent through the speaker. Soundcards expect to receive samples in blocks instead of one sample at a time. The soundcard's block length has to be preconfigured and some power of 2, commonly in the range of 256 (2^8) to 16384 (2^16). This step collects samples into bunches to match the soundcard's block length.  If too many samples are generated to fit into one block, Quiet sends one block's worth and stores the rest for the next block. If more samples are needed to fill a block, Quiet checks its send queue to see if more data frames are ready and fills with silence otherwise.", 
            "title": "Block Buffer"
        }, 
        {
            "location": "/how/#receiving", 
            "text": "The receiver is running on a separate device from the transmitter. Here we will take samples collected by our microphone and decode the transmitted message.", 
            "title": "Receiving"
        }, 
        {
            "location": "/how/#block-buffer_1", 
            "text": "The soundcard will have collected floating-point samples of sound recorded by the microphone. These samples are sent to us in blocks made of multiple samples, just as when we sent samples to the speaker. Each block's length is a some power of 2.  Our block buffer serves as a temporary store of samples as we run the decoding process.", 
            "title": "Block Buffer"
        }, 
        {
            "location": "/how/#downconversion", 
            "text": "We have to invert the upconversion process so that the original signal's center is shifted back down to 0 Hz. This should be matched to the transmitter so that we shift down by the same frequency interval that we shifted up.", 
            "title": "Downconversion"
        }, 
        {
            "location": "/how/#decimation", 
            "text": "This step inverts interpolation. First we apply a low-pass filter to our signal and then we throw away samples. This should also be matched to the transmitter. For example, if we had chosen to interpolate by 2, now we will decimate by 2.", 
            "title": "Decimation"
        }, 
        {
            "location": "/how/#frame-detection", 
            "text": "The resulting stream of samples should now resemble what we transmitted. When we sent our frame, we started it with a preamble. Now we will search for the preamble in the incoming samples. This is an ongoing process and will continue to run as long as no preamble is found.", 
            "title": "Frame Detection"
        }, 
        {
            "location": "/how/#synchronization-and-equalization", 
            "text": "The preamble is made up of a few different parts. The first part of the preamble is easily detectable so that we know where the frame begins. The next part of the preamble helps us synchronize our timing to the transmitter's timing in a precise way.  From the section on Payload Modulation, we described how we convert binary data into floating-point amplitudes. One of the challenges we face in decoding is deciding at which point it will be appropriate to read these floating-point samples. The preamble helps us accomplish this by giving us a predictable sequence to look for. Even if noise is present on top of the preamble, we can still achieve a pretty good synchronization by looking for successive samples.  We will also use the preamble to compensate for the uneven frequency response of the transmit and receive channel. It is typical that our transmission channel will emphasize certain frequencies and attenuate others. We use the preamble to invert this bias introduced by the channel so that the signal we receive looks nearly flat again.", 
            "title": "Synchronization and Equalization"
        }, 
        {
            "location": "/how/#demodulate-header", 
            "text": "With our clock aligned to the transmitter's, we are ready to begin decoding data. We start by decoding the modulated header samples. This data includes checksums of the payload and the header itself, as well as the type of modulation and error correection used in the payload. If the checksum of the decoded header data matches the checksum sent with the header, then we proceed to decoding the payload.", 
            "title": "Demodulate Header"
        }, 
        {
            "location": "/how/#demodulation", 
            "text": "", 
            "title": "Demodulation"
        }, 
        {
            "location": "/how/#demodulation_1", 
            "text": "Using the demodulation method specified by the header, we now demodulate all of the frame's payload samples. We perform  soft demodulation  so that the samples are demodulated into 8-bit \"soft\" bits. That is, for each bit of data transmitted, we now have an 8-bit value that reflects our belief about what might have been transmitted. A soft bit of 0 means that we are highly confident that a 0 was transmitted, 255 means that we are highly confident that a 1 was transmitted, and intermediate values mean we have some level of uncertainty. A value of 128 means that we believe either bit was equally likely. Preserving this level of uncertainty will help us during the error correction phase, as bits with lower confidence will accumulate less error.  To use our BPSK example from the modulation section, where we transmitted -1.0 for '0' and 1.0 for '1', imagine that we receive the sequence [0.9, -0.95, 0.1, 0.9]. If we were to decode these back to single bits, then we would decode this sequence as [1, 0, 1, 1]. However, if we use soft bits, we get [242, 6, 140, 242]. This better captures our uncertainty about the '0.1' sample we received, which is nearly as likely to be '0' as it is '1'.", 
            "title": "Demodulation"
        }, 
        {
            "location": "/how/#error-correction_1", 
            "text": "Now that we have the soft bits demodulated, our next step will be to apply the error correction techniques for the redundancy we added during modulation. The error correction will need to be good enough to decode the samples in spite of other noise occuring. Even the signal itself becomes noise, as echoes of the signal are picked up by the microphone.", 
            "title": "Error Correction"
        }, 
        {
            "location": "/how/#data-integrity", 
            "text": "Finally, we take the checksum value stored in the header and compare to a checksum of the data recovered after error correction. If these checksums match, we can be relatively confident that we have received the transmitted message. The bits can now be passed to the user.  The checksum stage is optional. Some applications may be well suited to receive messages with some errors. It is up to the user of Quiet Modem to decide whether to checksums should be used.", 
            "title": "Data Integrity"
        }, 
        {
            "location": "/how/#thread-safety", 
            "text": "The Quiet Modem library has some features that help it work well in a  multithreaded  environment. In particular, Quiet assumes that the interface to the soundcard will run on a different thread than the user application. Quiet attempts to decouple its functionality so that it can be used in a threadsafe way.", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/how/#ring-buffer", 
            "text": "One of the key components of Quiet's threadsafety is a  ring buffer  that allows safe communication between threads. Quiet's ring buffer allows any number of readers and any number of writers. If the buffer is empty or full, it has mechanisms to allow readers and writers to block until data or space in the buffer is available.  In general, we try to keep frames of data in buffers, rather than modulated samples. This is because a modulated frame uses much more memory than the demodulated payload data.", 
            "title": "Ring Buffer"
        }, 
        {
            "location": "/how/#send-queue", 
            "text": "On the transmit side of Quiet, we use a ringbuffer to build a send queue. This allows senders to queue up packets for transmission as capacity allows. When the soundcard is ready for more samples, Quiet can read from the send queue and modulate one or more frames to fill up the soundcard buffer as necessary.", 
            "title": "Send Queue"
        }, 
        {
            "location": "/how/#receive-queue", 
            "text": "On the receive side of Quiet, we have a receive queue. Samples are continuously read from the microphone into Quiet's decoder. When it has successfully decoded a packet, the packet's payload is written as a complete frame into the receive queue. Users of Quiet can perform a blocking read of this queue which will wait until a frame is ready.", 
            "title": "Receive Queue"
        }, 
        {
            "location": "/how/#quietjs", 
            "text": "", 
            "title": "Quiet.js"
        }, 
        {
            "location": "/how/#emscripten", 
            "text": "", 
            "title": "Emscripten"
        }, 
        {
            "location": "/how/#javascript-wrapper", 
            "text": "", 
            "title": "Javascript Wrapper"
        }, 
        {
            "location": "/profiles/", 
            "text": "Profiles\n\n\nProfiles are the configuration system of Quiet Modem. A single profile sets all of the parameters for both the transmitter and the receiver. Quiet uses a JSON-based serialization for profiles, and any given profile works across all Quiet platforms.\n\n\nQuiet comes with some starter profiles. These can be used out of the box with good success in a variety of use cases. They will also make a good starting point for more tuning and testing, should you decide to tweak Quiet to fit your use case specifically.\n\n\nStructure\n\n\nProfiles are stored in a file called \nquiet-profiles.json\n. Inside this file is a single JSON object. The top-level keys of this object are names of profiles, e.g. \nultrasonic-whisper\n. The corresponding value for this key contains another object which provides a complete profile for Quiet's transmitter and receiver.\n\n\nQuiet Profile Lab\n\n\nThe \nQuiet Profile Lab\n is an interactive testbench that runs in your browser. This allows you to test out new profiles with the speakers and mic in your computer. The Lab has instrumentation that can help you understand how various options change Quiet's behavior.\n\n\nmod_scheme\n\n\nThis sets the payload modulation mode for Quiet. Most methods come in a variety of bit depths.\n\n\nGaussian Minimum Shift Keying \nwikipedia\n\n\nThis mode is selected with \nmod_scheme\n set to \ngmsk\n. This mode is not compatible with OFDM operation.\n\n\nPhase Shift Keying \nwikipedia\n\n\nThis method can be pictured as a unit circle in the complex plane. Each bit representation contains the same magnitude and varies only in phase on this unit circle.\n\n\nComes in \npsk2\n, \npsk4\n, \npsk8\n, \npsk16\n, \npsk32\n, \npsk64\n, \npsk128\n, \npsk256\n variants.\n\n\nDifferential Phase Shift Keying \nwikipedia\n\n\nThis modulation method has the same constellation as PSK, but modulates changes in subsequent bits rather than the bits themselves.\n\n\nComes in \ndpsk2\n, \ndpsk4\n, \ndpsk8\n, \ndpsk16\n, \ndpsk32\n, \ndpsk64\n, \ndpsk128\n, \ndpsk256\n variants.\n\n\nAmplitude Shift Keying \nwikipedia\n\n\nThis modulation scheme uses only the real axis of the complex plane. Bits are encoded as various amplitude levels on the carrier signal.\n\n\nComes in \nask2\n, \nask4\n, \nask8\n, \nask16\n, \nask32\n, \nask64\n, \nask128\n, \nask256\n variants.\n\n\nAmplitude Phase Shift Keying \nwikipedia\n\n\nThis scheme can be pictured as concentric circles on the complex plane. Greater amplitude values move modulation out to a larger circle, while changes in phase move to different points along the circle.\n\n\nComes in \napsk2\n, \napsk4\n, \napsk8\n, \napsk16\n, \napsk32\n, \napsk64\n, \napsk128\n, \napsk256\n variants.\n\n\nQuadrature Amplitude Shift Keying \nwikipedia\n\n\nThis modulation scheme uses a grid of points in the complex plane. Each symbol corresponds to a point along the grid.\n\n\nComes in \nqam2\n, \nqam4\n, \nqam8\n, \nqam16\n, \nqam32\n, \nqam64\n, \nqam128\n, \nqam256\n, \nqam512\n, \nqam1024\n, \nqam2048\n, \nqam4096\n variants.\n\n\nOptimal QASK\n\n\nMiscellaneous\n\n\nofdm\n\n\nofdm.num_subcarriers\n\n\nofdm.cyclic_prefx_length\n\n\nofdm.taper_length\n\n\nofdm.left_band\n\n\nofdm.right_band\n\n\nchecksum_scheme\n\n\nChecksum \nwikipedia\n\n\nCyclic redundancy check \nwikipedia\n\n\ninner_fec_scheme\n\n\nRepetition Code \nwikipedia\n\n\nHamming \nwikipedia\n\n\nGolay \nwikipedia\n\n\nSECDED \nwikipedia\n\n\nConvolutional Codes \nwikipedia\n\n\nReed-Solomon \nwikipedia\n\n\nouter_fec_scheme\n\n\nThis accepts the same values as \ninner_fec_scheme\n.\n\n\nframe_length\n\n\nmodulation\n\n\nmodulation.center_frequency\n\n\nmodulation.gain\n\n\ninterpolation\n\n\ninterpolation.shape\n\n\nrrcos\n\n\ninterpolation.samples_per_symbol\n\n\ninterpolation.symbol_delay\n\n\ninterpolation.excess_bandwidth\n\n\nencoder_filters\n\n\nencoder_filters.dc_filter_alpha\n\n\nresampler\n\n\nresampler.delay\n\n\nresampler.bandwidth\n\n\nresampler.attenuation\n\n\nresampler.filter_bank_size", 
            "title": "Profiles"
        }, 
        {
            "location": "/profiles/#profiles", 
            "text": "Profiles are the configuration system of Quiet Modem. A single profile sets all of the parameters for both the transmitter and the receiver. Quiet uses a JSON-based serialization for profiles, and any given profile works across all Quiet platforms.  Quiet comes with some starter profiles. These can be used out of the box with good success in a variety of use cases. They will also make a good starting point for more tuning and testing, should you decide to tweak Quiet to fit your use case specifically.", 
            "title": "Profiles"
        }, 
        {
            "location": "/profiles/#structure", 
            "text": "Profiles are stored in a file called  quiet-profiles.json . Inside this file is a single JSON object. The top-level keys of this object are names of profiles, e.g.  ultrasonic-whisper . The corresponding value for this key contains another object which provides a complete profile for Quiet's transmitter and receiver.", 
            "title": "Structure"
        }, 
        {
            "location": "/profiles/#quiet-profile-lab", 
            "text": "The  Quiet Profile Lab  is an interactive testbench that runs in your browser. This allows you to test out new profiles with the speakers and mic in your computer. The Lab has instrumentation that can help you understand how various options change Quiet's behavior.", 
            "title": "Quiet Profile Lab"
        }, 
        {
            "location": "/profiles/#mod_scheme", 
            "text": "This sets the payload modulation mode for Quiet. Most methods come in a variety of bit depths.", 
            "title": "mod_scheme"
        }, 
        {
            "location": "/profiles/#gaussian-minimum-shift-keying-wikipedia", 
            "text": "This mode is selected with  mod_scheme  set to  gmsk . This mode is not compatible with OFDM operation.", 
            "title": "Gaussian Minimum Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#phase-shift-keying-wikipedia", 
            "text": "This method can be pictured as a unit circle in the complex plane. Each bit representation contains the same magnitude and varies only in phase on this unit circle.  Comes in  psk2 ,  psk4 ,  psk8 ,  psk16 ,  psk32 ,  psk64 ,  psk128 ,  psk256  variants.", 
            "title": "Phase Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#differential-phase-shift-keying-wikipedia", 
            "text": "This modulation method has the same constellation as PSK, but modulates changes in subsequent bits rather than the bits themselves.  Comes in  dpsk2 ,  dpsk4 ,  dpsk8 ,  dpsk16 ,  dpsk32 ,  dpsk64 ,  dpsk128 ,  dpsk256  variants.", 
            "title": "Differential Phase Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#amplitude-shift-keying-wikipedia", 
            "text": "This modulation scheme uses only the real axis of the complex plane. Bits are encoded as various amplitude levels on the carrier signal.  Comes in  ask2 ,  ask4 ,  ask8 ,  ask16 ,  ask32 ,  ask64 ,  ask128 ,  ask256  variants.", 
            "title": "Amplitude Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#amplitude-phase-shift-keying-wikipedia", 
            "text": "This scheme can be pictured as concentric circles on the complex plane. Greater amplitude values move modulation out to a larger circle, while changes in phase move to different points along the circle.  Comes in  apsk2 ,  apsk4 ,  apsk8 ,  apsk16 ,  apsk32 ,  apsk64 ,  apsk128 ,  apsk256  variants.", 
            "title": "Amplitude Phase Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#quadrature-amplitude-shift-keying-wikipedia", 
            "text": "This modulation scheme uses a grid of points in the complex plane. Each symbol corresponds to a point along the grid.  Comes in  qam2 ,  qam4 ,  qam8 ,  qam16 ,  qam32 ,  qam64 ,  qam128 ,  qam256 ,  qam512 ,  qam1024 ,  qam2048 ,  qam4096  variants.", 
            "title": "Quadrature Amplitude Shift Keying wikipedia"
        }, 
        {
            "location": "/profiles/#optimal-qask", 
            "text": "", 
            "title": "Optimal QASK"
        }, 
        {
            "location": "/profiles/#miscellaneous", 
            "text": "", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/profiles/#ofdm", 
            "text": "", 
            "title": "ofdm"
        }, 
        {
            "location": "/profiles/#ofdmnum_subcarriers", 
            "text": "", 
            "title": "ofdm.num_subcarriers"
        }, 
        {
            "location": "/profiles/#ofdmcyclic_prefx_length", 
            "text": "", 
            "title": "ofdm.cyclic_prefx_length"
        }, 
        {
            "location": "/profiles/#ofdmtaper_length", 
            "text": "", 
            "title": "ofdm.taper_length"
        }, 
        {
            "location": "/profiles/#ofdmleft_band", 
            "text": "", 
            "title": "ofdm.left_band"
        }, 
        {
            "location": "/profiles/#ofdmright_band", 
            "text": "", 
            "title": "ofdm.right_band"
        }, 
        {
            "location": "/profiles/#checksum_scheme", 
            "text": "", 
            "title": "checksum_scheme"
        }, 
        {
            "location": "/profiles/#checksum-wikipedia", 
            "text": "", 
            "title": "Checksum wikipedia"
        }, 
        {
            "location": "/profiles/#cyclic-redundancy-check-wikipedia", 
            "text": "", 
            "title": "Cyclic redundancy check wikipedia"
        }, 
        {
            "location": "/profiles/#inner_fec_scheme", 
            "text": "", 
            "title": "inner_fec_scheme"
        }, 
        {
            "location": "/profiles/#repetition-code-wikipedia", 
            "text": "", 
            "title": "Repetition Code wikipedia"
        }, 
        {
            "location": "/profiles/#hamming-wikipedia", 
            "text": "", 
            "title": "Hamming wikipedia"
        }, 
        {
            "location": "/profiles/#golay-wikipedia", 
            "text": "", 
            "title": "Golay wikipedia"
        }, 
        {
            "location": "/profiles/#secded-wikipedia", 
            "text": "", 
            "title": "SECDED wikipedia"
        }, 
        {
            "location": "/profiles/#convolutional-codes-wikipedia", 
            "text": "", 
            "title": "Convolutional Codes wikipedia"
        }, 
        {
            "location": "/profiles/#reed-solomon-wikipedia", 
            "text": "", 
            "title": "Reed-Solomon wikipedia"
        }, 
        {
            "location": "/profiles/#outer_fec_scheme", 
            "text": "This accepts the same values as  inner_fec_scheme .", 
            "title": "outer_fec_scheme"
        }, 
        {
            "location": "/profiles/#frame_length", 
            "text": "", 
            "title": "frame_length"
        }, 
        {
            "location": "/profiles/#modulation", 
            "text": "", 
            "title": "modulation"
        }, 
        {
            "location": "/profiles/#modulationcenter_frequency", 
            "text": "", 
            "title": "modulation.center_frequency"
        }, 
        {
            "location": "/profiles/#modulationgain", 
            "text": "", 
            "title": "modulation.gain"
        }, 
        {
            "location": "/profiles/#interpolation", 
            "text": "", 
            "title": "interpolation"
        }, 
        {
            "location": "/profiles/#interpolationshape", 
            "text": "", 
            "title": "interpolation.shape"
        }, 
        {
            "location": "/profiles/#rrcos", 
            "text": "", 
            "title": "rrcos"
        }, 
        {
            "location": "/profiles/#interpolationsamples_per_symbol", 
            "text": "", 
            "title": "interpolation.samples_per_symbol"
        }, 
        {
            "location": "/profiles/#interpolationsymbol_delay", 
            "text": "", 
            "title": "interpolation.symbol_delay"
        }, 
        {
            "location": "/profiles/#interpolationexcess_bandwidth", 
            "text": "", 
            "title": "interpolation.excess_bandwidth"
        }, 
        {
            "location": "/profiles/#encoder_filters", 
            "text": "", 
            "title": "encoder_filters"
        }, 
        {
            "location": "/profiles/#encoder_filtersdc_filter_alpha", 
            "text": "", 
            "title": "encoder_filters.dc_filter_alpha"
        }, 
        {
            "location": "/profiles/#resampler", 
            "text": "", 
            "title": "resampler"
        }, 
        {
            "location": "/profiles/#resamplerdelay", 
            "text": "", 
            "title": "resampler.delay"
        }, 
        {
            "location": "/profiles/#resamplerbandwidth", 
            "text": "", 
            "title": "resampler.bandwidth"
        }, 
        {
            "location": "/profiles/#resamplerattenuation", 
            "text": "", 
            "title": "resampler.attenuation"
        }, 
        {
            "location": "/profiles/#resamplerfilter_bank_size", 
            "text": "", 
            "title": "resampler.filter_bank_size"
        }
    ]
}